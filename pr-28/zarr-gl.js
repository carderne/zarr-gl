var t,e,r={},n={};function a(t){var e=n[t];if(void 0!==e)return e.exports;var i=n[t]={exports:{}};return r[t](i,i.exports,a),i.exports}a.m=r,a.d=(t,e)=>{for(var r in e)a.o(e,r)&&!a.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},a.f={},a.e=t=>Promise.all(Object.keys(a.f).reduce(((e,r)=>(a.f[r](t,e),e)),[])),a.u=t=>t+".zarr-gl.js",a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),a.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},t={792:0},e=e=>{var r,n,{ids:i,modules:s,runtime:o}=e,c=0;for(r in s)a.o(s,r)&&(a.m[r]=s[r]);for(o&&o(a);c<i.length;c++)n=i[c],a.o(t,n)&&t[n]&&t[n][0](),t[i[c]]=0},a.f.j=(r,n)=>{var i=a.o(t,r)?t[r]:void 0;if(0!==i)if(i)n.push(i[1]);else{var s=import("./"+a.u(r)).then(e,(e=>{throw 0!==t[r]&&(t[r]=void 0),e}));s=Promise.race([s,new Promise((e=>i=t[r]=[e]))]),n.push(i[1]=s)}};var i={};function s(t,e){return Math.floor((t+180)/360*Math.pow(2,e))}function o(t,e){return Math.floor((1-Math.log(Math.tan(t*Math.PI/180)+1/Math.cos(t*Math.PI/180))/Math.PI)/2*Math.pow(2,e))}a.d(i,{l:()=>vt});const c=t=>t.join(","),h=t=>{const[e,r,n]=t,a=1/2**e;return[a,r*a,n*a]},d=(t,e,r)=>{const n=t.createShader(e);if(!n)throw new Error(`createShader failed ${e}`);if(t.shaderSource(n,r),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS)){const r=t.getShaderInfoLog(n);throw t.deleteShader(n),new Error(`Failed to create shader ${e}: ${r}`)}return n},u=(t,e,r)=>{const n=t.createProgram();if(!n)throw new Error("createProgram failed");if(t.attachShader(n,e),t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS)){const e=t.getProgramInfoLog(n);throw t.deleteProgram(n),new Error(`Failed to create program: ${e}`)}return n},l=(t,e,r)=>{const n=t.getUniformLocation(e,r);if(!n)throw new Error(`Failed to get Uniform Location for ${r}`);return n},f=t=>{const e=t.createTexture();if(!e)throw new Error("Failed to create texture");return e},m=t=>{const e=t.createBuffer();if(!e)throw new Error("Failed to create buffer");return e},p=(t,e,r)=>{const n=t.createFramebuffer();if(!n)throw new Error("Failed to create framebuffer");const a=t.createTexture();if(!a)throw new Error("Failed to create texture for framebuffer");return t.bindTexture(t.TEXTURE_2D,a),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,r,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0),{framebuffer:n,texture:a}},_=class{chunk;chunks;loader;dimensions;shape;dimArrs;data=null;dataCache;z;x;y;loading=!1;loadingPromise=null;tileTexture;vertexBuffer;pixCoordBuffer;constructor({chunk:t,chunks:e,loader:r,dimensions:n,shape:a,dimArrs:i,z:s,x:o,y:c,gl:h}){this.chunk=t,this.chunks=e,this.loader=r,this.dimensions=n,this.shape=a,this.dimArrs=i,this.dataCache={},this.z=s,this.x=o,this.y=c,this.tileTexture=f(h),this.vertexBuffer=m(h),this.pixCoordBuffer=m(h)}async fetchData(t){const e=(({selector:t,dimensions:e,dimArrs:r,shape:n,chunks:a,x:i,y:s})=>e.reduce(((e,o,c)=>{if(["x","lon"].includes(o))return e.flatMap((t=>[[...t,i]]));if(["y","lat"].includes(o))return e.flatMap((t=>[[...t,s]]));const h=a[c],d=r[o];if(void 0===h||void 0===d)throw new Error("Need at least 1D array");const u=t[o],l=Array.isArray(u)?u.map((t=>d.indexOf(t))):void 0!==u?[d.indexOf(u)]:Array.from({length:n[c]},((t,e)=>e)),f=[...new Set(l.map((t=>Math.floor(t/h))))];return e.flatMap((t=>f.map((e=>[...t,e]))))}),[[]]))({selector:t,dimensions:this.dimensions,dimArrs:this.dimArrs,shape:this.shape,chunks:this.chunks,x:this.x,y:this.y}),r=e[0];if(1!==e.length||!r)throw new Error("Need exactly one chunk per tile");const n=r.join(",");return this.dataCache[n]?(this.data=this.dataCache[n],this.data):(this.loadingPromise||(this.loadingPromise=(async()=>{this.loading=!0;const e=this.dimensions.map((e=>{if(["x","y"].includes(e))return null;if(void 0===t[e])return null;{const r=this.dimArrs[e]?.findIndex((r=>r===t[e]));if(void 0===r)throw new Error("Couldnt extract indices from dimArrs");return r}})),a=await this.loader.getChunk(r);return this.loading=!1,this.loadingPromise=null,this.data=this.sliceChunkData(a,e),this.dataCache[n]=this.data,this.data})()),this.loadingPromise)}getDimension(t){const e=this.dimensions.indexOf(t);if(-1!==e)return this.chunks[e]}sliceChunkData(t,e){const{data:r,shape:n,stride:a}=t,i=(t,r)=>{if(r>=e.length)return[t];const s=e[r],o=n[r]??1,c=a[r]??1;if(null===s){const e=[];for(let n=0;n<o;n++)e.push(...i(t+n*c,r+1));return e}if(void 0===s)throw new Error("Index is undefined");return i(t+s*c,r+1)},s=i(0,0),o=new Float32Array(s.length),c=r;for(let t=0;t<s.length;t++)o[t]=c[s[t]]??0;return o}};function y(t,e,r,n={}){return void 0!==e&&void 0!==r&&(n={...n,headers:{...n.headers,Range:`bytes=${e}-${e+r-1}`}}),fetch(t,n)}function g(t,e){const r="string"==typeof t?new URL(t):t;r.pathname.endsWith("/")||(r.pathname+="/");const n=new URL(e.slice(1),r);return n.search=r.search,n}async function b(t){if(404!==t.status){if(200===t.status||206===t.status)return new Uint8Array(await t.arrayBuffer());throw new Error(`Unexpected response status ${t.status} ${t.statusText}`)}}const w=class{url;#t;#e;constructor(t,e={}){this.url=t,this.#t=e.overrides??{},this.#e=e.useSuffixRequest??!1}#r(t){return e=this.#t,r=t,{...e,...r,headers:{...e.headers,...r.headers}};var e,r}async get(t,e={}){let r=g(this.url,t).href;return b(await fetch(r,this.#r(e)))}async getRange(t,e,r={}){let n,a=g(this.url,t),i=this.#r(r);return n="suffixLength"in e?await async function(t,e,r,n){if(n)return fetch(t,{...r,headers:{...r.headers,Range:`bytes=-${e}`}});let a=await fetch(t,{...r,method:"HEAD"});if(!a.ok)return a;let i=a.headers.get("Content-Length"),s=Number(i);return y(t,s-e,s,r)}(a,e.suffixLength,i,this.#e):await y(a,e.offset,e.length,i),b(n)}};class E extends Error{constructor(t,e={}){super(`Node not found: ${t}`,e),this.name="NodeNotFoundError"}}class v extends Error{constructor(t){super(`Missing key: ${t}`),this.name="KeyError"}}class x{#n;constructor(t,e,r){"number"==typeof t?this.#n=new Uint8Array(t):t instanceof ArrayBuffer?this.#n=new Uint8Array(t,e,r):this.#n=new Uint8Array(Array.from(t,(t=>t?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return this.#n.byteOffset}get byteLength(){return this.#n.byteLength}get buffer(){return this.#n.buffer}get length(){return this.#n.length}get(t){let e=this.#n[t];return"number"==typeof e?0!==e:e}set(t,e){this.#n[t]=e?1:0}fill(t){this.#n.fill(t?1:0)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class T{_data;chars;#a;constructor(t,e,r,n){if(this.chars=t,this.#a=new TextEncoder,"number"==typeof e)this._data=new Uint8Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this._data=new Uint8Array(e,r,n);else{let r=Array.from(e);this._data=new Uint8Array(r.length*t);for(let t=0;t<r.length;t++)this.set(t,r[t])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(t){const e=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);return(new TextDecoder).decode(e).replace(/\x00/g,"")}set(t,e){const r=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);r.fill(0),r.set(this.#a.encode(e))}fill(t){const e=this.#a.encode(t);for(let t=0;t<this.length;t++)this._data.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class A{#i;chars;constructor(t,e,r,n){if(this.chars=t,"number"==typeof e)this.#i=new Int32Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this.#i=new Int32Array(e,r,n);else{const r=e,n=new A(t,1);this.#i=new Int32Array(function*(){for(let t of r)n.set(0,t),yield*n.#i}())}}get BYTES_PER_ELEMENT(){return this.#i.BYTES_PER_ELEMENT*this.chars}get byteLength(){return this.#i.byteLength}get byteOffset(){return this.#i.byteOffset}get buffer(){return this.#i.buffer}get length(){return this.#i.length/this.chars}get(t){const e=this.chars*t;let r="";for(let t=0;t<this.chars;t++)r+=String.fromCodePoint(this.#i[e+t]);return r.replace(/\u0000/g,"")}set(t,e){const r=this.chars*t,n=this.#i.subarray(r,r+this.chars);n.fill(0);for(let t=0;t<this.chars;t++)n[t]=e.codePointAt(t)??0}fill(t){this.set(0,t);let e=this.#i.subarray(0,this.chars);for(let t=1;t<this.length;t++)this.#i.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}function R(t){const e=(new TextDecoder).decode(t);return JSON.parse(e)}function k(t,e){const r=e/2,n=e-1;let a=0;for(let i=0;i<t.length;i+=e)for(let e=0;e<r;e+=1)a=t[i+e],t[i+e]=t[i+n-e],t[i+n-e]=a}function L(t){if("v2:object"===t)return globalThis.Array;let e=t.match(/v2:([US])(\d+)/);if(e){let[,t,r]=e;return("U"===t?A:T).bind(null,Number(r))}let r={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float16:globalThis.Float16Array,float32:Float32Array,float64:Float64Array,bool:x}[t];return C(r,`Unknown or unsupported data_type: ${t}`),r}function U(t,e){const r=t.length;"string"==typeof e&&(e="C"===e?Array.from({length:r},((t,e)=>e)):Array.from({length:r},((t,e)=>r-1-e))),C(r===e.length,"Order length must match the number of dimensions.");let n=1,a=new Array(r);for(let r=e.length-1;r>=0;r--)a[e[r]]=n,n*=t[e[r]];return a}function P({name:t,configuration:e}){if("default"===t){const t=e?.separator??"/";return e=>["c",...e].join(t)}if("v2"===t){const t=e?.separator??".";return e=>e.join(t)||"0"}throw new Error(`Unknown chunk key encoding: ${t}`)}function F(t){return"sharding_indexed"===t?.name}function S(t){return"uint64"!==t.data_type&&"int64"!==t.data_type||null==t.fill_value?t.fill_value:BigInt(t.fill_value)}function M(t,...e){if(!e.some((e=>t instanceof e)))throw t}function C(t,e=""){if(!t)throw new Error(e)}async function D(t,{format:e,signal:r}){const n=t instanceof Response?t:new Response(t);C(n.body,"Response does not contain body.");try{const t=new Response(n.body.pipeThrough(new DecompressionStream(e),{signal:r}));return await t.arrayBuffer()}catch{throw r?.throwIfAborted(),new Error(`Failed to decode ${e}`)}}class B{kind="array_to_array";constructor(t,e){C(t.keepbits>=0,"keepbits must be zero or positive")}static fromConfig(t,e){return new B(t,e)}encode(t){throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.")}decode(t){return t}}const N=function(){const t=new Uint32Array([305419896]);return!(18===new Uint8Array(t.buffer,t.byteOffset,t.byteLength)[0])}();function I(t){return"BYTES_PER_ELEMENT"in t?t.BYTES_PER_ELEMENT:4}class O{kind="array_to_bytes";#s;#o;#c;#h;#d;constructor(t,e){this.#d=t?.endian,this.#o=L(e.data_type),this.#h=e.shape,this.#s=U(e.shape,"C");const r=new this.#o(0);this.#c=r.BYTES_PER_ELEMENT}static fromConfig(t,e){return new O(t,e)}encode(t){let e=new Uint8Array(t.data.buffer);return N&&"big"===this.#d&&k(e,I(this.#o)),e}decode(t){return N&&"big"===this.#d&&k(t,I(this.#o)),{data:new this.#o(t.buffer,t.byteOffset,t.byteLength/this.#c),shape:this.#h,stride:this.#s}}}class ${kind="bytes_to_bytes";static fromConfig(){return new $}encode(t){throw new Error("Not implemented")}decode(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength-4)}}class X{kind="bytes_to_bytes";static fromConfig(t){return new X}encode(t){throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.")}async decode(t){const e=await D(t,{format:"gzip"});return new Uint8Array(e)}}function z(t,e){return C(!Number.isNaN(e),"JsonCodec allow_nan is false but NaN was encountered during encoding."),C(e!==Number.POSITIVE_INFINITY,"JsonCodec allow_nan is false but Infinity was encountered during encoding."),C(e!==Number.NEGATIVE_INFINITY,"JsonCodec allow_nan is false but -Infinity was encountered during encoding."),e}function V(t,e){return e instanceof Object&&!Array.isArray(e)?Object.keys(e).sort().reduce(((t,r)=>(t[r]=e[r],t)),{}):e}class W{configuration;kind="array_to_bytes";#u;#l;constructor(t={}){this.configuration=t;const{encoding:e="utf-8",skipkeys:r=!1,ensure_ascii:n=!0,check_circular:a=!0,allow_nan:i=!0,sort_keys:s=!0,indent:o,strict:c=!0}=t;let h=t.separators;h||(h=o?[", ",": "]:[",",":"]),this.#u={encoding:e,skipkeys:r,ensure_ascii:n,check_circular:a,allow_nan:i,indent:o,separators:h,sort_keys:s},this.#l={strict:c}}static fromConfig(t){return new W(t)}encode(t){const{indent:e,encoding:r,ensure_ascii:n,check_circular:a,allow_nan:i,sort_keys:s}=this.#u;C("utf-8"===r,"JsonCodec does not yet support non-utf-8 encoding.");const o=[];C(a,"JsonCodec does not yet support skipping the check for circular references during encoding."),i||o.push(z),s&&o.push(V);const c=Array.from(t.data);let h;c.push("|O"),c.push(t.shape),o.length&&(h=(t,e)=>{let r=e;for(let e of o)r=e(t,r);return r});let d=JSON.stringify(c,h,e);return n&&(d=d.replace(/[\u007F-\uFFFF]/g,(t=>{const e=`0000${t.charCodeAt(0).toString(16)}`;return`\\u${e.substring(e.length-4)}`}))),(new TextEncoder).encode(d)}decode(t){const{strict:e}=this.#l;C(e,"JsonCodec does not yet support non-strict decoding.");const r=R(t),n=r.pop();return r.pop(),C(n,"0D not implemented for JsonCodec."),{data:r,shape:n,stride:U(n,"C")}}}function j(t){return t instanceof x||t instanceof T||t instanceof A?new Proxy(t,{get:(t,e)=>t.get(Number(e)),set:(t,e,r)=>(t.set(Number(e),r),!0)}):t}class Y{kind="array_to_array";#f;#m;constructor(t,e){let r=t.order??"C",n=e.shape.length,a=new Array(n),i=new Array(n);if("C"===r)for(let t=0;t<n;++t)a[t]=t,i[t]=t;else if("F"===r)for(let t=0;t<n;++t)a[t]=n-t-1,i[t]=n-t-1;else a=r,a.forEach(((t,e)=>{C(void 0===i[t],`Invalid permutation: ${JSON.stringify(r)}`),i[t]=e}));this.#f=a,this.#m=i}static fromConfig(t,e){return new Y(t,e)}encode(t){return function(t,e){let r=function(t){return C(t.shape.length===t.stride.length,"Shape and stride must have the same length."),t.stride.map(((t,e)=>({stride:t,index:e}))).sort(((t,e)=>e.stride-t.stride)).map((t=>t.index))}(t);return C(r.length===e.length,"Orders must match"),r.every(((t,r)=>t===e[r]))}(t,this.#m)?t:function(t,e){let r=function(t,e){let r;return r=t.data instanceof T||t.data instanceof A?new t.constructor(t.data.length,t.data.chars):new t.constructor(t.data.length),{data:r,shape:t.shape,stride:U(t.shape,e)}}(t,e),n=t.shape.length,a=t.data.length,i=Array(n).fill(0),s=j(t.data),o=j(r.data);for(let e=0;e<a;e++){let a=0;for(let t=0;t<n;t++)a+=i[t]*r.stride[t];o[a]=s[e],i[0]+=1;for(let e=0;e<n;e++)if(i[e]===t.shape[e]){if(e+1===n)break;i[e]=0,i[e+1]+=1}}return r}(t,this.#m)}decode(t){return{data:t.data,shape:t.shape,stride:U(t.shape,this.#f)}}}class G{kind="array_to_bytes";#h;#p;constructor(t){this.#h=t,this.#p=U(t,"C")}static fromConfig(t,e){return new G(e.shape)}encode(t){throw new Error("Method not implemented.")}decode(t){let e=new TextDecoder,r=new DataView(t.buffer),n=Array(r.getUint32(0,!0)),a=4;for(let i=0;i<n.length;i++){let s=r.getUint32(a,!0);a+=4,n[i]=e.decode(t.buffer.slice(a,a+s)),a+=s}return{data:n,shape:this.#h,stride:this.#p}}}class H{kind="bytes_to_bytes";static fromConfig(t){return new H}encode(t){throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.")}async decode(t){const e=await D(t,{format:"deflate"});return new Uint8Array(e)}}const Z=(new Map).set("blosc",(()=>a.e(121).then(a.bind(a,121)).then((t=>t.default)))).set("lz4",(()=>a.e(274).then(a.bind(a,274)).then((t=>t.default)))).set("zstd",(()=>a.e(505).then(a.bind(a,505)).then((t=>t.default)))).set("gzip",(()=>X)).set("zlib",(()=>H)).set("transpose",(()=>Y)).set("bytes",(()=>O)).set("crc32c",(()=>$)).set("vlen-utf8",(()=>G)).set("json2",(()=>W)).set("bitround",(()=>B));function J(t){let e;return{async encode(r){e||(e=await q(t));for(const t of e.array_to_array)r=await t.encode(r);let n=await e.array_to_bytes.encode(r);for(const t of e.bytes_to_bytes)n=await t.encode(n);return n},async decode(r){e||(e=await q(t));for(let t=e.bytes_to_bytes.length-1;t>=0;t--)r=await e.bytes_to_bytes[t].decode(r);let n=await e.array_to_bytes.decode(r);for(let t=e.array_to_array.length-1;t>=0;t--)n=await e.array_to_array[t].decode(n);return n}}}async function q(t){let e,r=t.codecs.map((async t=>{let e=await(Z.get(t.name)?.());return C(e,`Unknown codec: ${t.name}`),{Codec:e,meta:t}})),n=[],a=[];for await(let{Codec:i,meta:s}of r){let r=i.fromConfig(s.configuration,t);switch(r.kind){case"array_to_array":n.push(r);break;case"array_to_bytes":e=r;break;default:a.push(r)}}return e||(C("v2:object"!==t.data_type,`Cannot encode ${t.data_type} to bytes without a codec`),e=O.fromConfig({endian:"little"},t)),{array_to_array:n,array_to_bytes:e,bytes_to_bytes:a}}const K=18446744073709551615n;function Q(t,e,r,n){C(t.store.getRange,"Store does not support range requests");let a=t.store.getRange.bind(t.store),i=e.map(((t,e)=>t/n.chunk_shape[e])),s=J({data_type:"uint64",shape:[...i,2],codecs:n.index_codecs}),o={};return async e=>{let n,c=e.map(((t,e)=>Math.floor(t/i[e]))),h=t.resolve(r(c)).path;if(h in o)n=o[h];else{let t=4,e=16*i.reduce(((t,e)=>t*e),1),r=await a(h,{suffixLength:e+t});n=o[h]=r?await s.decode(r):null}if(null===n)return;let{data:d,shape:u,stride:l}=n,f=e.map(((t,e)=>t%u[e])).reduce(((t,e,r)=>t+e*l[r]),0),m=d[f],p=d[f+1];return m!==K||p!==K?a(h,{offset:Number(m),length:Number(p)}):void 0}}class tt{store;path;constructor(t,e="/"){this.store=t,this.path=e}resolve(t){let e=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new tt(this.store,decodeURIComponent(new URL(t,e).pathname))}}class et extends tt{kind="group";#_;constructor(t,e,r){super(t,e),this.#_=r}get attrs(){return this.#_.attributes}}function rt(t){const e=t.find((t=>"transpose"===t.name));return e?.configuration?.order??"C"}const nt=Symbol("zarrita.context");class at extends tt{kind="array";#_;[nt];constructor(t,e,r){super(t,e),this.#_={...r,fill_value:S(r)},this[nt]=function(t,e){let{configuration:r}=e.codecs.find(F)??{},n={encode_chunk_key:P(e.chunk_key_encoding),TypedArray:L(e.data_type),fill_value:e.fill_value};if(r){let a=rt(r.codecs);return{...n,kind:"sharded",chunk_shape:r.chunk_shape,codec:J({data_type:e.data_type,shape:r.chunk_shape,codecs:r.codecs}),get_strides:t=>U(t,a),get_chunk_bytes:Q(t,e.chunk_grid.configuration.chunk_shape,n.encode_chunk_key,r)}}let a=rt(e.codecs);return{...n,kind:"regular",chunk_shape:e.chunk_grid.configuration.chunk_shape,codec:J({data_type:e.data_type,shape:e.chunk_grid.configuration.chunk_shape,codecs:e.codecs}),get_strides:t=>U(t,a),async get_chunk_bytes(e,r){let a=n.encode_chunk_key(e),i=t.resolve(a).path;return t.store.get(i,r)}}}(this,r)}get attrs(){return this.#_.attributes}get shape(){return this.#_.shape}get chunks(){return this[nt].chunk_shape}get dtype(){return this.#_.data_type}async getChunk(t,e){let r=this[nt],n=await r.get_chunk_bytes(t,e);if(!n){let t=r.chunk_shape.reduce(((t,e)=>t*e),1),e=new r.TypedArray(t);return e.fill(r.fill_value),{data:e,shape:r.chunk_shape,stride:r.get_strides(r.chunk_shape)}}return r.codec.decode(n)}is(t){return function(t,e){if("number"!==e&&"bigint"!==e&&"boolean"!==e&&"object"!==e&&"string"!==e)return t===e;let r="bool"===t;if("boolean"===e)return r;let n=t.startsWith("v2:U")||t.startsWith("v2:S");if("string"===e)return n;let a="int64"===t||"uint64"===t;if("bigint"===e)return a;let i="v2:object"===t;return"object"===e?i:!(n||a||r||i)}(this.dtype,t)}}let it=function(){let t=new WeakMap;function e(e){let r=t.get(e)??{v2:0,v3:0};return t.set(e,r),r}return{increment(t,r){e(t)[r]+=1},version_max(t){let r=e(t);return r.v3>r.v2?"v3":"v2"}}}();async function st(t,e){let{path:r}=t.resolve(".zarray"),n=await t.store.get(r);if(!n)throw new E("v2 array",{cause:new v(r)});return it.increment(t.store,"v2"),new at(t.store,t.path,function(t,e={}){let r=[],n=function(t){if("|O"===t)return{data_type:"v2:object"};let e=t.match(/^([<|>])(.*)$/);C(e,`Invalid dtype: ${t}`);let[,r,n]=e,a={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f2:"float16",f4:"float32",f8:"float64"}[n]??(n.startsWith("S")||n.startsWith("U")?`v2:${n}`:void 0);return C(a,`Unsupported or unknown dtype: ${t}`),"|"===r?{data_type:a}:{data_type:a,endian:"<"===r?"little":"big"}}(t.dtype);"F"===t.order&&r.push({name:"transpose",configuration:{order:"F"}}),"endian"in n&&"big"===n.endian&&r.push({name:"bytes",configuration:{endian:"big"}});for(let{id:e,...n}of t.filters??[])r.push({name:e,configuration:n});if(t.compressor){let{id:e,...n}=t.compressor;r.push({name:e,configuration:n})}return{zarr_format:3,node_type:"array",shape:t.shape,data_type:n.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:t.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:t.dimension_separator??"."}},codecs:r,fill_value:t.fill_value,attributes:e}}(R(n),e))}async function ot(t,e){let{path:r}=t.resolve(".zgroup"),n=await t.store.get(r);if(!n)throw new E("v2 group",{cause:new v(r)});return it.increment(t.store,"v2"),new et(t.store,t.path,function(t,e={}){return{zarr_format:3,node_type:"group",attributes:e}}(R(n),e))}async function ct(t,e={}){let r="store"in t?t.store:t,n=it.version_max(r),a="v2"===n?ct.v2:ct.v3,i="v2"===n?ct.v3:ct.v2;return a(t,e).catch((r=>(M(r,E),i(t,e))))}function ht(t,e,r=null){return void 0===e&&(e=t,t=null),{start:t,stop:e,step:r}}ct.v2=async function(t,e={}){let r="store"in t?t:new tt(t),n={};return(e.attrs??1)&&(n=await async function(t){let e=await t.store.get(t.resolve(".zattrs").path);return e?R(e):{}}(r)),"array"===e.kind?st(r,n):"group"===e.kind?ot(r,n):st(r,n).catch((t=>(M(t,E),ot(r,n))))},ct.v3=async function(t,e={}){let r="store"in t?t:new tt(t),n=await async function(t){let{store:e,path:r}=t.resolve("zarr.json"),n=await t.store.get(r);if(!n)throw new E("v3 array or group",{cause:new v(r)});let a=R(n);return"array"===a.node_type&&(a.fill_value=S(a)),"array"===a.node_type?new at(e,t.path,a):new et(e,t.path,a)}(r);if(it.increment(r.store,"v3"),void 0===e.kind)return n;if("array"===e.kind&&n instanceof at)return n;if("group"===e.kind&&n instanceof et)return n;let a=n instanceof at?"array":"group";throw new Error(`Expected node of kind ${e.kind}, found ${a}.`)};class dt extends Error{constructor(t){super(t),this.name="IndexError"}}class ut{dim_sel;dim_len;dim_chunk_len;nitems;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){t=function(t,e){return(t=Math.trunc(t))<0&&(t=e+t),(t>=e||t<0)&&function(t){throw new dt(`index out of bounds for dimension with length ${t}`)}(e),t}(t,e),this.dim_sel=t,this.dim_len=e,this.dim_chunk_len=r,this.nitems=1}*[Symbol.iterator](){const t=Math.floor(this.dim_sel/this.dim_chunk_len),e=t*this.dim_chunk_len,r=this.dim_sel-e;yield{dim_chunk_ix:t,dim_chunk_sel:r}}}class lt{start;stop;step;dim_len;dim_chunk_len;nitems;nchunks;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){const[n,a,i]=function({start:t,stop:e,step:r},n){if(0===r)throw new Error("slice step cannot be zero");const a=(r=r??1)<0,[i,s]=a?[-1,n-1]:[0,n];return null===t?t=a?s:i:t<0?(t+=n)<i&&(t=i):t>s&&(t=s),null===e?e=a?i:s:e<0?(e+=n)<i&&(e=i):e>s&&(e=s),[t,e,r]}(t,e);this.start=n,this.stop=a,this.step=i,this.step<1&&function(){throw new dt("only slices with step >= 1 are supported")}(),this.dim_len=e,this.dim_chunk_len=r,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const t=Math.floor(this.start/this.dim_chunk_len),e=Math.ceil(this.stop/this.dim_chunk_len);for(const r of function*(t,e,r=1){void 0===e&&(e=t,t=0);for(let n=t;n<e;n+=r)yield n}(t,e)){const t=r*this.dim_chunk_len,e=Math.min(this.dim_len,(r+1)*this.dim_chunk_len),n=e-t;let a=0,i=0;if(this.start<t){const e=(t-this.start)%this.step;e&&(i+=this.step-e),a=Math.ceil((t-this.start)/this.step)}else i=this.start-t;const s=this.stop>e?n:this.stop-t,o=[i,s,this.step],c=[a,a+Math.ceil((s-i)/this.step),1];yield{dim_chunk_ix:r,dim_chunk_sel:o,dim_out_sel:c}}}}class ft{dim_indexers;shape;constructor({selection:t,shape:e,chunk_shape:r}){this.dim_indexers=function(t,e){let r=[];return null===t?r=e.map((t=>ht(null))):Array.isArray(t)&&(r=t.map((t=>t??ht(null)))),function(t,e){t.length>e.length&&function(t,e){throw new dt(`too many indicies for array; expected ${e.length}, got ${t.length}`)}(t,e)}(r,e),r}(t,e).map(((t,n)=>new("number"==typeof t?ut:lt)({dim_sel:t,dim_len:e[n],dim_chunk_len:r[n]}))),this.shape=this.dim_indexers.filter((t=>t instanceof lt)).map((t=>t.nitems))}*[Symbol.iterator](){for(const t of function*(...t){if(0===t.length)return;const e=t.map((t=>t[Symbol.iterator]())),r=e.map((t=>t.next()));if(r.some((t=>t.done)))throw new Error("Input contains an empty iterator.");for(let n=0;;){if(r[n].done){if(e[n]=t[n][Symbol.iterator](),r[n]=e[n].next(),++n>=e.length)return}else yield r.map((({value:t})=>t)),n=0;r[n]=e[n].next()}}(...this.dim_indexers)){const e=t.map((t=>t.dim_chunk_ix)),r=t.map((t=>"dim_out_sel"in t?{from:t.dim_chunk_sel,to:t.dim_out_sel}:{from:t.dim_chunk_sel,to:null}));yield{chunk_coords:e,mapping:r}}}}function mt(t,e=0,r){let n=r??t.length-e;return{length:n,subarray:(r,a=n)=>mt(t,e+r,a-r),set(r,n=0){for(let a=0;a<r.length;a++)t[e+n+a]=r.get(a)},get:r=>t[e+r]}}function pt(t){return globalThis.Array.isArray(t.data)?{data:mt(t.data),stride:t.stride,bytes_per_element:1}:{data:new Uint8Array(t.data.buffer,t.data.byteOffset,t.data.byteLength),stride:t.stride,bytes_per_element:t.data.BYTES_PER_ELEMENT}}const _t={prepare:(t,e,r)=>({data:t,shape:e,stride:r}),set_scalar(t,e,r){let n=pt(t);gt(n,e,function(t,e){if(globalThis.Array.isArray(t.data))return mt([e]);let r=new(function(t){return"chars"in t?t.constructor.bind(null,t.chars):t.constructor}(t.data))([e]);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}(t,r),n.bytes_per_element)},set_from_chunk(t,e,r){let n=pt(t);bt(n,pt(e),n.bytes_per_element,r)}};function yt(t,e,r){return r<0&&e<t?Math.floor((t-e-1)/-r)+1:t<e?Math.floor((e-t-1)/r)+1:0}function gt(t,e,r,n){if(0===e.length)return void t.data.set(r,0);const[a,...i]=e,[s,...o]=t.stride;if("number"==typeof a)return void gt({data:t.data.subarray(s*a*n),stride:o},i,r,n);const[c,h,d]=a,u=yt(c,h,d);if(0!==i.length)for(let e=0;e<u;e++)gt({data:t.data.subarray(s*(c+d*e)*n),stride:o},i,r,n);else for(let e=0;e<u;e++)t.data.set(r,s*(c+d*e)*n)}function bt(t,e,r,n){const[a,...i]=n,[s,...o]=t.stride,[c,...h]=e.stride;if(null===a.from)return 0===i.length?void t.data.set(e.data.subarray(0,r),a.to*r):void bt({data:t.data.subarray(s*a.to*r),stride:o},e,r,i);if(null===a.to){if(0===i.length){let n=a.from*r;return void t.data.set(e.data.subarray(n,n+r),0)}return void bt(t,{data:e.data.subarray(c*a.from*r),stride:h},r,i)}const[d,u,l]=a.to,[f,m,p]=a.from,_=yt(d,u,l);if(0!==i.length)for(let n=0;n<_;n++)bt({data:t.data.subarray(s*(d+n*l)*r),stride:o},{data:e.data.subarray(c*(f+n*p)*r),stride:h},r,i);else{if(1===l&&1===p&&1===s&&1===c){let n=f*r,a=_*r;return void t.data.set(e.data.subarray(n,n+a),d*r)}for(let n=0;n<_;n++){let a=c*(f+p*n)*r;t.data.set(e.data.subarray(a,a+r),s*(d+l*n)*r)}}}const wt=async(t,e,r)=>Object.fromEntries(await Promise.all(e.map((async e=>{const n=await ct(t.resolve(`${r}/${e}`),{kind:"array"}),a=await async function(t,e=null,r={}){return async function(t,e,r,n){let a=t[nt],i=new ft({selection:e,shape:t.shape,chunk_shape:t.chunks}),s=n.prepare(new a.TypedArray(i.shape.reduce(((t,e)=>t*e),1)),i.shape,a.get_strides(i.shape)),o=r.create_queue?.()??function(){const t=[];return{add:e=>t.push(e()),onIdle:()=>Promise.all(t)}}();for(const{chunk_coords:e,mapping:a}of i)o.add((async()=>{let{data:i,shape:o,stride:c}=await t.getChunk(e,r.opts),h=n.prepare(i,o,c);n.set_from_chunk(s,h,a)}));return await o.onIdle(),0===i.shape.length?function(t){return"get"in t?t.get(0):t[0]}(s.data):s}(t,e,r,_t)}(n);return[e,Array.from(a.data)]})))),Et=async(t,e,r,n)=>(async(t,e,r,n)=>{const a=(t=>t?async e=>{const r=await t(e);return new w(r.url,{overrides:{headers:r.headers,credentials:r.credentials}})}:t=>new w(t))(n),i=await a(t),s=(await ct(i,{kind:"group"})).attrs.multiscales,{levels:o,maxZoom:c,tileSize:h,crs:d}=(t=>{const e=t[0]?.datasets;if(!e)throw new Error("No `multiscales` or `datasets` in zarr metadata");const r=e.map((t=>Number(t.path)));if(0===r.length)throw new Error("No levels found in multiscales metadata");const n=Math.max(...r),a=e[0]?.pixels_per_tile,i=e[0]?.crs??"EPSG:3857";if(!a)throw new Error("No `pixels_per_tile` value in `multiscales` metadata.");return{levels:r,maxZoom:n,tileSize:a,crs:i}})(s),u=o[0],l=function(t){return new tt(t??new Map)}(i),{dimensions:f,fillValue:m}="v2"===r?await(async(t,e,r,n)=>{const a=e.resolve(`${n}/${r}`),i=(await ct(a,{kind:"array"})).attrs._ARRAY_DIMENSIONS,s=a.resolve(".zarray").path,o=await t.get(s);if(!o)throw new Error(`Could not load metadata from ${s}`);return{dimensions:i,fillValue:JSON.parse((new TextDecoder).decode(o)).fill_value??0}})(i,l,e,u):await(async(t,e,r,n)=>{const a=e.resolve(`${n}/${r}`).resolve("zarr.json").path,i=await t.get(a);if(!i)throw new Error(`Could not load metadata from ${a}`);const s=JSON.parse((new TextDecoder).decode(i));return{dimensions:s.dimension_names??[],fillValue:s.fill_value??0}})(i,l,e,u),p=await ct(l.resolve(`${u}/${e}`),{kind:"array"}),_=p.shape,y=p.chunks,g=await(async(t,e,r)=>Object.fromEntries(await Promise.all(e.map((async e=>[`${e}/${r}`,await ct(t.resolve(`${e}/${r}`),{kind:"array"})])))))(l,o,e);return{loaders:g,dimensions:f,dimArrs:await wt(l,f,u),levels:o,maxZoom:c,tileSize:h,crs:d,shape:_,chunks:y,fillValue:m}})(t,e,r,n);class vt{type;renderingMode;map;id;zarrSource;zarrVersion;variable;selector;invalidate;transformRequest;cmapLength;cmap;vmin;vmax;opacity;minRenderZoom;loaders;tiles;maxZoom;fillValue;gl;program;scaleLoc;shiftXLoc;shiftYLoc;matrixLoc;vminLoc;vmaxLoc;opacityLoc;noDataLoc;vertexLoc;cmapTex;cmapLoc;vertexArr;pixCoordArr;texLoc;pixCoordLoc;frameBuffers;isUpdating;canvasWidth;canvasHeight;renderProgram;renderVertexLoc;renderTexLoc;vertexBuffer;constructor({id:t,source:e,version:r,variable:n,selector:a,map:i,colormap:s,vmin:o,vmax:c,opacity:h=1,minRenderZoom:d=3,invalidate:u=()=>{},transformRequest:l}){this.type="custom",this.renderingMode="2d",this.id=t,this.zarrSource=e,this.zarrVersion=r,this.variable=n,this.selector=a??{},this.invalidate=u,this.transformRequest=l,this.cmap=new Float32Array(s.flat().map((t=>t/255))),this.cmapLength=s.length,this.vmin=o,this.vmax=c,this.opacity=h,this.minRenderZoom=d,this.map=i,this.loaders={},this.tiles={},this.maxZoom=4,this.fillValue=0,this.frameBuffers={current:null,next:null},this.isUpdating=!1,this.canvasWidth=512,this.canvasHeight=512}setOpacity(t){this.opacity=t,this.invalidate()}setVminVmax(t,e){this.vmin=t,this.vmax=e,this.invalidate()}async setVariable(t){this.variable=t,this.tiles={},await this.prepareTiles(),this.getVisibleTiles(),await this.prefetchTileData(),this.invalidate()}async setSelector(t){this.selector=t,await this.prefetchTileData(),this.invalidate()}async prefetchTileData(){const t=this.getVisibleTiles().map((t=>{const e=c(t),r=this.tiles[e];return r&&!r.data?r.fetchData(this.selector):null})).filter((t=>null!==t));t.length>0&&(await Promise.all(t),this.invalidate())}getVisibleTiles(){const t=((t,e)=>e?Math.min(Math.max(3,Math.floor(t)),e):Math.max(0,Math.floor(t)))(this.map.getZoom(),this.maxZoom);if(!this.loaders[t])return[];const e=this.map.getBounds()?.toArray();if(!e)throw new Error("Couldn't get map bounds");return((t,e)=>{const[[r,n],[a,i]]=e,c=s(r,t),h=s(a,t),d=o(i,t),u=o(n,t),l=[];for(let e=c;e<=h;e++)for(let r=d;r<=u;r++)l.push([t,e,r]);return l})(t,e)}async prepareTiles(){if(void 0===this.gl)throw new Error("Cant prepareTiles with no GL context set");const t=this.gl,{loaders:e,dimensions:r,dimArrs:n,levels:a,maxZoom:i,shape:s,chunks:o,fillValue:c}=await Et(this.zarrSource,this.variable,this.zarrVersion,this.transformRequest);this.maxZoom=i,this.fillValue=c,a.forEach((a=>{const i=a+"/"+this.variable,c=e[i];if(!c)throw new Error(`Failed to get loader for ${i}`);this.loaders[a]=c,Array.from({length:Math.pow(2,a)},((e,i)=>{Array.from({length:Math.pow(2,a)},((e,h)=>{const d=[a,i,h].join(","),u=[h,i];this.tiles[d]=new _({chunk:u,chunks:o,loader:c,gl:t,dimensions:r,dimArrs:n,shape:s,z:a,x:i,y:h})}))}))}))}async getTileValue(t,e,r,n){const a=this.maxZoom,i=[a,s(t,a),o(e,a)],d=c(i),u=this.tiles[d];if(u){const[t,e,s]=h(i),[o,c]=[r-e,n-s],d=await u.fetchData(this.selector),l=u.getDimension("x"),f=u.getDimension("y"),[m,p]=[Math.round(o*l*2**a),Math.round(c*f*2**a)],_=d[p*l+m];if(_)return _}return-1}async onAdd(t,e){this.gl=e;const r=d(e,e.VERTEX_SHADER,"#version 300 es\nuniform float scale;\nuniform float shift_x;\nuniform float shift_y;\nuniform mat4 matrix;\n\nin vec2 pix_coord_in;\nin vec2 vertex;\n\nout vec2 pix_coord;\n\nvoid main() {\n  vec2 a = vec2(vertex.x * scale + shift_x, vertex.y * scale + shift_y);\n  gl_Position = matrix * vec4(a, 0.0, 1.0);\n  pix_coord = pix_coord_in;\n}\n"),n=d(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nuniform float vmin;\nuniform float vmax;\nuniform float opacity;\nuniform float nodata;\n\nuniform sampler2D tex;\nuniform sampler2D cmap;\n\nin vec2 pix_coord;\nout vec4 color;\n\nvoid main() {\n  float value = texture(tex, pix_coord).r;\n  if (value == nodata) {\n    discard;\n  }\n  float norm = (value - vmin)/(vmax - vmin);\n  float cla = clamp(norm, 0.0, 1.0);\n  vec4 c = texture(cmap, vec2(cla, 0.5));\n  color = vec4(c.r, c.g, c.b, opacity);\n}\n");this.program=u(e,r,n),this.scaleLoc=l(e,this.program,"scale"),this.shiftXLoc=l(e,this.program,"shift_x"),this.shiftYLoc=l(e,this.program,"shift_y"),this.matrixLoc=l(e,this.program,"matrix"),this.vminLoc=l(e,this.program,"vmin"),this.vmaxLoc=l(e,this.program,"vmax"),this.opacityLoc=l(e,this.program,"opacity"),this.noDataLoc=l(e,this.program,"nodata"),this.cmapTex=f(e),this.cmapLoc=l(e,this.program,"cmap"),this.texLoc=l(e,this.program,"tex"),this.vertexLoc=e.getAttribLocation(this.program,"vertex"),this.vertexArr=new Float32Array([-1,1,-1,-1,1,1,1,-1]),this.pixCoordLoc=e.getAttribLocation(this.program,"pix_coord_in"),this.pixCoordArr=new Float32Array([0,0,0,1,1,0,1,1]),this.canvasWidth=e.canvas.width,this.canvasHeight=e.canvas.height,this.frameBuffers.current=p(e,this.canvasWidth,this.canvasHeight),this.frameBuffers.next=p(e,this.canvasWidth,this.canvasHeight),await this.prepareTiles(),this.vertexBuffer=m(e);const a=d(e,e.VERTEX_SHADER,"#version 300 es\nin vec2 vertex;\nout vec2 texCoord;\nvoid main() {\n  gl_Position = vec4(vertex, 0.0, 1.0);\n  texCoord = vertex * 0.5 + 0.5;  // Convert from [-1,1] to [0,1]\n}\n"),i=d(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\nuniform sampler2D tex;\nin vec2 texCoord;\nout vec4 fragColor;\nvoid main() {\n  fragColor = texture(tex, texCoord);\n}\n");this.renderProgram=u(e,a,i),this.renderVertexLoc=e.getAttribLocation(this.renderProgram,"vertex"),this.renderTexLoc=l(e,this.renderProgram,"tex"),e.deleteShader(a),e.deleteShader(i),await this.prefetchTileData()}prerender(t,e){if(this.isUpdating)return;t.useProgram(this.program),t.canvas.width===this.canvasWidth&&t.canvas.height===this.canvasHeight||(this.canvasWidth=t.canvas.width,this.canvasHeight=t.canvas.height,this.frameBuffers.current=p(t,this.canvasWidth,this.canvasHeight),this.frameBuffers.next=p(t,this.canvasWidth,this.canvasHeight)),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.frameBuffers.next.framebuffer),t.bindFramebuffer(t.READ_FRAMEBUFFER,this.frameBuffers.current.framebuffer),t.blitFramebuffer(0,0,this.canvasWidth,this.canvasHeight,0,0,this.canvasWidth,this.canvasHeight,t.COLOR_BUFFER_BIT,t.NEAREST),t.bindFramebuffer(t.FRAMEBUFFER,this.frameBuffers.next.framebuffer),t.viewport(0,0,this.canvasWidth,this.canvasHeight),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.cmapTex),t.uniform1i(this.cmapLoc,1),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,t.RGB16F,this.cmapLength,1,0,t.RGB,t.FLOAT,this.cmap),t.uniform1f(this.vminLoc,this.vmin),t.uniform1f(this.vmaxLoc,this.vmax),t.uniform1f(this.opacityLoc,this.opacity),t.uniform1f(this.noDataLoc,this.fillValue),t.uniformMatrix4fv(this.matrixLoc,!1,e);const r=this.getVisibleTiles();this.prefetchTileData();for(const e of r){const r=c(e),n=this.tiles[r];if(!n)continue;if(!n.data)continue;const[a,i,s]=h(e);t.uniform1f(this.scaleLoc,a),t.uniform1f(this.shiftXLoc,i),t.uniform1f(this.shiftYLoc,s),t.bindBuffer(t.ARRAY_BUFFER,n.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.vertexArr,t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,n.pixCoordBuffer),t.bufferData(t.ARRAY_BUFFER,this.pixCoordArr,t.STATIC_DRAW),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,n.tileTexture),t.uniform1i(this.texLoc,0),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE);const o=n.getDimension("x"),d=n.getDimension("y");t.texImage2D(t.TEXTURE_2D,0,t.R16F,o,d,0,t.RED,t.FLOAT,n.data),t.enableVertexAttribArray(this.vertexLoc),t.vertexAttribPointer(this.vertexLoc,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.pixCoordLoc),t.vertexAttribPointer(this.pixCoordLoc,2,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLE_STRIP,0,4)}const n=this.frameBuffers.current;this.frameBuffers.current=this.frameBuffers.next,this.frameBuffers.next=n,this.isUpdating=!1}render(t,e){this.frameBuffers.current&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.viewport(0,0,this.canvasWidth,this.canvasHeight),t.useProgram(this.renderProgram),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.frameBuffers.current.texture),t.uniform1i(this.renderTexLoc,0),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,-1,1,1]),t.STATIC_DRAW),t.enableVertexAttribArray(this.renderVertexLoc),t.vertexAttribPointer(this.renderVertexLoc,2,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLE_STRIP,0,4))}}var xt=i.l;export{xt as ZarrLayer};