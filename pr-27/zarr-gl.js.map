{"version":3,"file":"zarr-gl.js","mappings":"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","sources":["webpack://zarr-gl/webpack/runtime/import chunk loading","webpack://zarr-gl/webpack/bootstrap","webpack://zarr-gl/webpack/runtime/define property getters","webpack://zarr-gl/webpack/runtime/ensure chunk","webpack://zarr-gl/webpack/runtime/get javascript chunk filename","webpack://zarr-gl/webpack/runtime/hasOwnProperty shorthand","webpack://zarr-gl/webpack/runtime/make namespace object","webpack://zarr-gl/./src/utils.ts","webpack://zarr-gl/./node_modules/zarrita/dist/src/typedarray.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/util.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/bitround.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/bytes.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/crc32c.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/gzip.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/json2.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/transpose.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/vlen-utf8.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/zlib.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/codecs/sharding.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/hierarchy.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/indexing/util.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/indexing/indexer.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/indexing/ops.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/indexing/get.js","webpack://zarr-gl/./src/tile.ts","webpack://zarr-gl/./node_modules/@zarrita/storage/dist/src/util.js","webpack://zarr-gl/./node_modules/@zarrita/storage/dist/src/fetch.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/errors.js","webpack://zarr-gl/./node_modules/zarrita/dist/src/open.js","webpack://zarr-gl/./src/store.ts","webpack://zarr-gl/./src/index.ts"],"sourcesContent":["// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\nvar installChunk = (data) => {\n\tvar {ids, modules, runtime} = data;\n\t// add \"modules\" to the modules object,\n\t// then flag all \"ids\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tfor(moduleId in modules) {\n\t\tif(__webpack_require__.o(modules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = modules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tfor(;i < ids.length; i++) {\n\t\tchunkId = ids[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[ids[i]] = 0;\n\t}\n\n}\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// import() chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[1]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = import(\"./\" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {\n\t\t\t\t\t\tif(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t\tvar promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])\n\t\t\t\t\tpromises.push(installedChunkData[1] = promise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no external install chunk\n\n// no on chunks loaded","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".zarr-gl.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type ChunkTuple = number[];\n\nexport type TileTuple = [number, number, number];\n\nexport function lon2tile(lon: number, zoom: number): number {\n  return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));\n}\n\nexport function lat2tile(lat: number, zoom: number): number {\n  return Math.floor(\n    ((1 -\n      Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) /\n      2) *\n      Math.pow(2, zoom),\n  );\n}\n\nexport const getTilesAtZoom = (\n  zoom: number,\n  bounds: [[number, number], [number, number]],\n): TileTuple[] => {\n  const [[west, south], [east, north]] = bounds;\n  const nwX = lon2tile(west, zoom);\n  const seX = lon2tile(east, zoom);\n  const nwY = lat2tile(north, zoom);\n  const seY = lat2tile(south, zoom);\n\n  const tiles: TileTuple[] = [];\n  for (let x = nwX; x <= seX; x++) {\n    for (let y = nwY; y <= seY; y++) {\n      tiles.push([zoom, x, y]);\n    }\n  }\n\n  return tiles;\n};\n\nexport const keyToTile = (key: string): TileTuple => {\n  return key.split(\",\").map((d) => parseInt(d)) as TileTuple;\n};\n\nexport const tileToKey = (tile: TileTuple): string => {\n  return tile.join(\",\");\n};\n\nexport const tileToScale = (tile: TileTuple): [number, number, number] => {\n  const [z, x, y] = tile;\n  const scale = 1 / 2 ** z;\n  const shiftX = x * scale;\n  const shiftY = y * scale;\n  return [scale, shiftX, shiftY];\n};\n\nexport const zoomToLevel = (zoom: number, maxZoom: number): number => {\n  if (maxZoom) return Math.min(Math.max(3, Math.floor(zoom)), maxZoom);\n  return Math.max(0, Math.floor(zoom));\n};\n\nexport const createShader = (\n  gl: WebGL2RenderingContext,\n  type: GLenum,\n  source: string,\n): WebGLShader => {\n  const shader = gl.createShader(type);\n  if (!shader) {\n    throw new Error(`createShader failed ${type}`);\n  }\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!success) {\n    const msg = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(`Failed to create shader ${type}: ${msg}`);\n  }\n  return shader;\n};\n\nexport const createProgram = (\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram => {\n  const program = gl.createProgram();\n  if (!program) {\n    throw new Error(\"createProgram failed\");\n  }\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!success) {\n    const msg = gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    throw new Error(`Failed to create program: ${msg}`);\n  }\n  return program;\n};\n\nexport const mustGetUniformLocation = (\n  gl: WebGL2RenderingContext,\n  program: WebGLProgram,\n  name: string,\n): WebGLUniformLocation => {\n  const loc = gl.getUniformLocation(program, name);\n  if (!loc) {\n    throw new Error(`Failed to get Uniform Location for ${name}`);\n  }\n  return loc;\n};\n\nexport const mustCreateTexture = (gl: WebGL2RenderingContext): WebGLTexture => {\n  const tex = gl.createTexture();\n  if (!tex) {\n    throw new Error(\"Failed to create texture\");\n  }\n  return tex;\n};\n\nexport const mustCreateBuffer = (gl: WebGL2RenderingContext): WebGLBuffer => {\n  const buf = gl.createBuffer();\n  if (!buf) {\n    throw new Error(\"Failed to create buffer\");\n  }\n  return buf;\n};\n\nexport const mustCreateFramebuffer = (\n  gl: WebGL2RenderingContext,\n  width: number,\n  height: number,\n): { framebuffer: WebGLFramebuffer; texture: WebGLTexture } => {\n  const framebuffer = gl.createFramebuffer();\n  if (!framebuffer) {\n    throw new Error(\"Failed to create framebuffer\");\n  }\n\n  const texture = gl.createTexture();\n  if (!texture) {\n    throw new Error(\"Failed to create texture for framebuffer\");\n  }\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  return { framebuffer, texture };\n};\n\nexport const getChunks = ({\n  selector,\n  dimensions,\n  dimArrs,\n  shape,\n  chunks,\n  x,\n  y,\n}: {\n  selector: Record<string, number>;\n  dimensions: string[];\n  dimArrs: Record<string, number[]>;\n  shape: number[];\n  chunks: number[];\n  x: number;\n  y: number;\n}): ChunkTuple[] => {\n  return dimensions.reduce<ChunkTuple[]>(\n    (acc, dim, i) => {\n      if ([\"x\", \"lon\"].includes(dim)) {\n        return acc.flatMap((a) => [[...a, x]]);\n      } else if ([\"y\", \"lat\"].includes(dim)) {\n        return acc.flatMap((tuple) => [[...tuple, y]]);\n      }\n\n      const chunkSize = chunks[i];\n      const coords = dimArrs[dim];\n      if (typeof chunkSize === \"undefined\" || typeof coords === \"undefined\") {\n        throw new Error(\"Need at least 1D array\");\n      }\n\n      const selectorValue = selector[dim];\n      const indices = Array.isArray(selectorValue)\n        ? selectorValue.map((v) => coords.indexOf(v))\n        : selectorValue !== undefined\n          ? [coords.indexOf(selectorValue)]\n          : Array.from({ length: shape[i]! }, (_, j) => j);\n\n      const uniqueChunkIndices = [\n        ...new Set(indices.map((index) => Math.floor(index / chunkSize))),\n      ];\n\n      return acc.flatMap((a) => uniqueChunkIndices.map((chunkIndex) => [...a, chunkIndex]));\n    },\n    [[]],\n  );\n};\n","/**\n * Custom array-like views (i.e., TypedArrays) for Zarr binary data buffers.\n *\n * @module\n */\n/**\n * An array-like view of a fixed-length boolean buffer.\n *\n * Encoded as 1 byte per value.\n */\nexport class BoolArray {\n    #bytes;\n    constructor(x, byteOffset, length) {\n        if (typeof x === \"number\") {\n            this.#bytes = new Uint8Array(x);\n        }\n        else if (x instanceof ArrayBuffer) {\n            this.#bytes = new Uint8Array(x, byteOffset, length);\n        }\n        else {\n            this.#bytes = new Uint8Array(Array.from(x, (v) => (v ? 1 : 0)));\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return 1;\n    }\n    get byteOffset() {\n        return this.#bytes.byteOffset;\n    }\n    get byteLength() {\n        return this.#bytes.byteLength;\n    }\n    get buffer() {\n        return this.#bytes.buffer;\n    }\n    get length() {\n        return this.#bytes.length;\n    }\n    get(idx) {\n        let value = this.#bytes[idx];\n        return typeof value === \"number\" ? value !== 0 : value;\n    }\n    set(idx, value) {\n        this.#bytes[idx] = value ? 1 : 0;\n    }\n    fill(value) {\n        this.#bytes.fill(value ? 1 : 0);\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n/**\n * An array-like view of a fixed-length byte buffer.\n *\n * Encodes a raw byte sequences without enforced encoding.\n */\nexport class ByteStringArray {\n    _data;\n    chars;\n    #encoder;\n    constructor(chars, x, byteOffset, length) {\n        this.chars = chars;\n        this.#encoder = new TextEncoder();\n        if (typeof x === \"number\") {\n            this._data = new Uint8Array(x * chars);\n        }\n        else if (x instanceof ArrayBuffer) {\n            if (length)\n                length = length * chars;\n            this._data = new Uint8Array(x, byteOffset, length);\n        }\n        else {\n            let values = Array.from(x);\n            this._data = new Uint8Array(values.length * chars);\n            for (let i = 0; i < values.length; i++) {\n                this.set(i, values[i]);\n            }\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return this.chars;\n    }\n    get byteOffset() {\n        return this._data.byteOffset;\n    }\n    get byteLength() {\n        return this._data.byteLength;\n    }\n    get buffer() {\n        return this._data.buffer;\n    }\n    get length() {\n        return this.byteLength / this.BYTES_PER_ELEMENT;\n    }\n    get(idx) {\n        const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);\n        // biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\n        return new TextDecoder().decode(view).replace(/\\x00/g, \"\");\n    }\n    set(idx, value) {\n        const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);\n        view.fill(0); // clear current\n        view.set(this.#encoder.encode(value));\n    }\n    fill(value) {\n        const encoded = this.#encoder.encode(value);\n        for (let i = 0; i < this.length; i++) {\n            this._data.set(encoded, i * this.chars);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n/**\n * An array-like view of a fixed-length Unicode string buffer.\n *\n * Encoded as UTF-32 code points.\n */\nexport class UnicodeStringArray {\n    #data;\n    chars;\n    constructor(chars, x, byteOffset, length) {\n        this.chars = chars;\n        if (typeof x === \"number\") {\n            this.#data = new Int32Array(x * chars);\n        }\n        else if (x instanceof ArrayBuffer) {\n            if (length)\n                length *= chars;\n            this.#data = new Int32Array(x, byteOffset, length);\n        }\n        else {\n            const values = x;\n            const d = new UnicodeStringArray(chars, 1);\n            this.#data = new Int32Array((function* () {\n                for (let str of values) {\n                    d.set(0, str);\n                    yield* d.#data;\n                }\n            })());\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return this.#data.BYTES_PER_ELEMENT * this.chars;\n    }\n    get byteLength() {\n        return this.#data.byteLength;\n    }\n    get byteOffset() {\n        return this.#data.byteOffset;\n    }\n    get buffer() {\n        return this.#data.buffer;\n    }\n    get length() {\n        return this.#data.length / this.chars;\n    }\n    get(idx) {\n        const offset = this.chars * idx;\n        let result = \"\";\n        for (let i = 0; i < this.chars; i++) {\n            result += String.fromCodePoint(this.#data[offset + i]);\n        }\n        // biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\n        return result.replace(/\\u0000/g, \"\");\n    }\n    set(idx, value) {\n        const offset = this.chars * idx;\n        const view = this.#data.subarray(offset, offset + this.chars);\n        view.fill(0); // clear current\n        for (let i = 0; i < this.chars; i++) {\n            view[i] = value.codePointAt(i) ?? 0;\n        }\n    }\n    fill(value) {\n        // encode once\n        this.set(0, value);\n        // copy the encoded values to all other elements\n        let encoded = this.#data.subarray(0, this.chars);\n        for (let i = 1; i < this.length; i++) {\n            this.#data.set(encoded, i * this.chars);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n//# sourceMappingURL=typedarray.js.map","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"./typedarray.js\";\nexport function json_encode_object(o) {\n    const str = JSON.stringify(o, null, 2);\n    return new TextEncoder().encode(str);\n}\nexport function json_decode_object(bytes) {\n    const str = new TextDecoder().decode(bytes);\n    return JSON.parse(str);\n}\nexport function byteswap_inplace(view, bytes_per_element) {\n    const numFlips = bytes_per_element / 2;\n    const endByteIndex = bytes_per_element - 1;\n    let t = 0;\n    for (let i = 0; i < view.length; i += bytes_per_element) {\n        for (let j = 0; j < numFlips; j += 1) {\n            t = view[i + j];\n            view[i + j] = view[i + endByteIndex - j];\n            view[i + endByteIndex - j] = t;\n        }\n    }\n}\nexport function get_ctr(data_type) {\n    if (data_type === \"v2:object\") {\n        return globalThis.Array;\n    }\n    let match = data_type.match(/v2:([US])(\\d+)/);\n    if (match) {\n        let [, kind, chars] = match;\n        // @ts-expect-error\n        return (kind === \"U\" ? UnicodeStringArray : ByteStringArray).bind(null, Number(chars));\n    }\n    // @ts-expect-error - We've checked that the key exists\n    let ctr = {\n        int8: Int8Array,\n        int16: Int16Array,\n        int32: Int32Array,\n        int64: globalThis.BigInt64Array,\n        uint8: Uint8Array,\n        uint16: Uint16Array,\n        uint32: Uint32Array,\n        uint64: globalThis.BigUint64Array,\n        float16: globalThis.Float16Array,\n        float32: Float32Array,\n        float64: Float64Array,\n        bool: BoolArray,\n    }[data_type];\n    assert(ctr, `Unknown or unsupported data_type: ${data_type}`);\n    return ctr;\n}\n/** Compute strides for 'C' or 'F' ordered array from shape */\nexport function get_strides(shape, order) {\n    const rank = shape.length;\n    if (typeof order === \"string\") {\n        order =\n            order === \"C\"\n                ? Array.from({ length: rank }, (_, i) => i) // Row-major (identity order)\n                : Array.from({ length: rank }, (_, i) => rank - 1 - i); // Column-major (reverse order)\n    }\n    assert(rank === order.length, \"Order length must match the number of dimensions.\");\n    let step = 1;\n    let stride = new Array(rank);\n    for (let i = order.length - 1; i >= 0; i--) {\n        stride[order[i]] = step;\n        step *= shape[order[i]];\n    }\n    return stride;\n}\n// https://zarr-specs.readthedocs.io/en/latest/v3/core/v3.0.html#chunk-key-encoding\nexport function create_chunk_key_encoder({ name, configuration, }) {\n    if (name === \"default\") {\n        const separator = configuration?.separator ?? \"/\";\n        return (chunk_coords) => [\"c\", ...chunk_coords].join(separator);\n    }\n    if (name === \"v2\") {\n        const separator = configuration?.separator ?? \".\";\n        return (chunk_coords) => chunk_coords.join(separator) || \"0\";\n    }\n    throw new Error(`Unknown chunk key encoding: ${name}`);\n}\nfunction coerce_dtype(dtype) {\n    if (dtype === \"|O\") {\n        return { data_type: \"v2:object\" };\n    }\n    let match = dtype.match(/^([<|>])(.*)$/);\n    assert(match, `Invalid dtype: ${dtype}`);\n    let [, endian, rest] = match;\n    let data_type = {\n        b1: \"bool\",\n        i1: \"int8\",\n        u1: \"uint8\",\n        i2: \"int16\",\n        u2: \"uint16\",\n        i4: \"int32\",\n        u4: \"uint32\",\n        i8: \"int64\",\n        u8: \"uint64\",\n        f2: \"float16\",\n        f4: \"float32\",\n        f8: \"float64\",\n    }[rest] ??\n        (rest.startsWith(\"S\") || rest.startsWith(\"U\") ? `v2:${rest}` : undefined);\n    assert(data_type, `Unsupported or unknown dtype: ${dtype}`);\n    if (endian === \"|\") {\n        return { data_type };\n    }\n    return { data_type, endian: endian === \"<\" ? \"little\" : \"big\" };\n}\nexport function v2_to_v3_array_metadata(meta, attributes = {}) {\n    let codecs = [];\n    let dtype = coerce_dtype(meta.dtype);\n    if (meta.order === \"F\") {\n        codecs.push({ name: \"transpose\", configuration: { order: \"F\" } });\n    }\n    if (\"endian\" in dtype && dtype.endian === \"big\") {\n        codecs.push({ name: \"bytes\", configuration: { endian: \"big\" } });\n    }\n    for (let { id, ...configuration } of meta.filters ?? []) {\n        codecs.push({ name: id, configuration });\n    }\n    if (meta.compressor) {\n        let { id, ...configuration } = meta.compressor;\n        codecs.push({ name: id, configuration });\n    }\n    return {\n        zarr_format: 3,\n        node_type: \"array\",\n        shape: meta.shape,\n        data_type: dtype.data_type,\n        chunk_grid: {\n            name: \"regular\",\n            configuration: {\n                chunk_shape: meta.chunks,\n            },\n        },\n        chunk_key_encoding: {\n            name: \"v2\",\n            configuration: {\n                separator: meta.dimension_separator ?? \".\",\n            },\n        },\n        codecs,\n        fill_value: meta.fill_value,\n        attributes,\n    };\n}\nexport function v2_to_v3_group_metadata(_meta, attributes = {}) {\n    return {\n        zarr_format: 3,\n        node_type: \"group\",\n        attributes,\n    };\n}\nexport function is_dtype(dtype, query) {\n    if (query !== \"number\" &&\n        query !== \"bigint\" &&\n        query !== \"boolean\" &&\n        query !== \"object\" &&\n        query !== \"string\") {\n        return dtype === query;\n    }\n    let is_boolean = dtype === \"bool\";\n    if (query === \"boolean\")\n        return is_boolean;\n    let is_string = dtype.startsWith(\"v2:U\") || dtype.startsWith(\"v2:S\");\n    if (query === \"string\")\n        return is_string;\n    let is_bigint = dtype === \"int64\" || dtype === \"uint64\";\n    if (query === \"bigint\")\n        return is_bigint;\n    let is_object = dtype === \"v2:object\";\n    if (query === \"object\")\n        return is_object;\n    return !is_string && !is_bigint && !is_boolean && !is_object;\n}\nexport function is_sharding_codec(codec) {\n    return codec?.name === \"sharding_indexed\";\n}\nexport function ensure_correct_scalar(metadata) {\n    if ((metadata.data_type === \"uint64\" || metadata.data_type === \"int64\") &&\n        metadata.fill_value != null) {\n        // @ts-expect-error - We've narrowed the type of fill_value correctly\n        return BigInt(metadata.fill_value);\n    }\n    return metadata.fill_value;\n}\n/**\n * Ensures an error matches expected type(s), otherwise rethrows.\n *\n * Unmatched errors bubble up, like Python's `except`. Narrows error types for\n * type-safe property access.\n *\n * @see {@link https://gist.github.com/manzt/3702f19abb714e21c22ce48851c75abf}\n *\n * @example\n * ```ts\n * class DatabaseError extends Error { }\n * class NetworkError extends Error { }\n *\n * try {\n *   await db.query();\n * } catch (err) {\n *   rethrow_unless(err, DatabaseError, NetworkError);\n *   err // DatabaseError | NetworkError\n * }\n * ```\n *\n * @param error - The error to check\n * @param errors - Expected error type(s)\n * @throws The original error if it doesn't match expected type(s)\n */\nexport function rethrow_unless(error, ...errors) {\n    if (!errors.some((ErrorClass) => error instanceof ErrorClass)) {\n        throw error;\n    }\n}\n/**\n * Make an assertion.\n *\n * Usage\n * @example\n * ```ts\n * const value: boolean = Math.random() <= 0.5;\n * assert(value, \"value is greater than than 0.5!\");\n * value // true\n * ```\n *\n * @param expression - The expression to test.\n * @param msg - The optional message to display if the assertion fails.\n * @throws an {@link Error} if `expression` is not truthy.\n */\nexport function assert(expression, msg = \"\") {\n    if (!expression) {\n        throw new Error(msg);\n    }\n}\n/**\n * @param {ArrayBuffer |ArrayBufferView | Response} data\n * @param {Object} options\n * @param {CompressionFormat} options.format\n * @param {AbortSignal} [options.signal]\n *\n * @returns {Promise<ArrayBuffer>}\n */\nexport async function decompress(data, { format, signal }) {\n    const response = data instanceof Response ? data : new Response(data);\n    assert(response.body, \"Response does not contain body.\");\n    try {\n        const decompressedResponse = new Response(response.body.pipeThrough(new DecompressionStream(format), { signal }));\n        const buffer = await decompressedResponse.arrayBuffer();\n        return buffer;\n    }\n    catch {\n        signal?.throwIfAborted();\n        throw new Error(`Failed to decode ${format}`);\n    }\n}\n//# sourceMappingURL=util.js.map","import { assert } from \"../util.js\";\n/**\n * A codec for bit-rounding.\n *\n * Reduces floating-point precision by truncating mantissa bits during encoding.\n * Decoding is a no-op as the process is lossy and precision cannot be restored.\n *\n * Note: {@link BitroundCodec.encode} is not yet implemented since Zarrita is\n * primarily used in read-only contexts (web browser). If you need encoding support,\n * please open an issue at {@link https://github.com/manzt/zarrita.js/issues}.\n *\n * @see {@link https://github.com/zarr-developers/numcodecs/blob/main/numcodecs/bitround.py}\n * for the original Python implementation.\n *\n * @remarks\n * Data types are not validated, and `float16` arrays are not supported (reflecting browser support).\n */\nexport class BitroundCodec {\n    kind = \"array_to_array\";\n    constructor(configuration, _meta) {\n        assert(configuration.keepbits >= 0, \"keepbits must be zero or positive\");\n    }\n    static fromConfig(configuration, meta) {\n        return new BitroundCodec(configuration, meta);\n    }\n    /**\n     * Encode a chunk of data with bit-rounding.\n     * @param _arr - The chunk to encode\n     */\n    encode(_arr) {\n        throw new Error(\"`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.\");\n    }\n    /**\n     * Decode a chunk of data (no-op).\n     * @param arr - The chunk to decode\n     * @returns The decoded chunk\n     */\n    decode(arr) {\n        return arr; // No-op as bit-rounding is lossy\n    }\n}\n//# sourceMappingURL=bitround.js.map","import { byteswap_inplace, get_ctr, get_strides } from \"../util.js\";\nconst LITTLE_ENDIAN_OS = system_is_little_endian();\nfunction system_is_little_endian() {\n    const a = new Uint32Array([0x12345678]);\n    const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return !(b[0] === 0x12);\n}\nfunction bytes_per_element(TypedArray) {\n    if (\"BYTES_PER_ELEMENT\" in TypedArray) {\n        return TypedArray.BYTES_PER_ELEMENT;\n    }\n    // Unicode string array is backed by a Int32Array.\n    return 4;\n}\nexport class BytesCodec {\n    kind = \"array_to_bytes\";\n    #stride;\n    #TypedArray;\n    #BYTES_PER_ELEMENT;\n    #shape;\n    #endian;\n    constructor(configuration, meta) {\n        this.#endian = configuration?.endian;\n        this.#TypedArray = get_ctr(meta.data_type);\n        this.#shape = meta.shape;\n        this.#stride = get_strides(meta.shape, \"C\");\n        // TODO: fix me.\n        // hack to get bytes per element since it's dynamic for string types.\n        const sample = new this.#TypedArray(0);\n        this.#BYTES_PER_ELEMENT = sample.BYTES_PER_ELEMENT;\n    }\n    static fromConfig(configuration, meta) {\n        return new BytesCodec(configuration, meta);\n    }\n    encode(arr) {\n        let bytes = new Uint8Array(arr.data.buffer);\n        if (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return bytes;\n    }\n    decode(bytes) {\n        if (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return {\n            data: new this.#TypedArray(bytes.buffer, bytes.byteOffset, bytes.byteLength / this.#BYTES_PER_ELEMENT),\n            shape: this.#shape,\n            stride: this.#stride,\n        };\n    }\n}\n//# sourceMappingURL=bytes.js.map","export class Crc32cCodec {\n    kind = \"bytes_to_bytes\";\n    static fromConfig() {\n        return new Crc32cCodec();\n    }\n    encode(_) {\n        throw new Error(\"Not implemented\");\n    }\n    decode(arr) {\n        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);\n    }\n}\n//# sourceMappingURL=crc32c.js.map","import { decompress } from \"../util.js\";\nexport class GzipCodec {\n    kind = \"bytes_to_bytes\";\n    static fromConfig(_) {\n        return new GzipCodec();\n    }\n    encode(_bytes) {\n        throw new Error(\"Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.\");\n    }\n    async decode(bytes) {\n        const buffer = await decompress(bytes, { format: \"gzip\" });\n        return new Uint8Array(buffer);\n    }\n}\n//# sourceMappingURL=gzip.js.map","import { assert, get_strides, json_decode_object } from \"../util.js\";\n// Reference: https://stackoverflow.com/a/21897413\nfunction throw_on_nan_replacer(_key, value) {\n    assert(!Number.isNaN(value), \"JsonCodec allow_nan is false but NaN was encountered during encoding.\");\n    assert(value !== Number.POSITIVE_INFINITY, \"JsonCodec allow_nan is false but Infinity was encountered during encoding.\");\n    assert(value !== Number.NEGATIVE_INFINITY, \"JsonCodec allow_nan is false but -Infinity was encountered during encoding.\");\n    return value;\n}\n// Reference: https://gist.github.com/davidfurlong/463a83a33b70a3b6618e97ec9679e490\nfunction sort_keys_replacer(_key, value) {\n    return value instanceof Object && !Array.isArray(value)\n        ? Object.keys(value)\n            .sort()\n            .reduce((sorted, key) => {\n            sorted[key] = value[key];\n            return sorted;\n        }, {})\n        : value;\n}\nexport class JsonCodec {\n    configuration;\n    kind = \"array_to_bytes\";\n    #encoder_config;\n    #decoder_config;\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n        // Reference: https://github.com/zarr-developers/numcodecs/blob/0878717a3613d91a453fe3d3716aa9c67c023a8b/numcodecs/json.py#L36\n        const { encoding = \"utf-8\", skipkeys = false, ensure_ascii = true, check_circular = true, allow_nan = true, sort_keys = true, indent, strict = true, } = configuration;\n        let separators = configuration.separators;\n        if (!separators) {\n            // ensure separators are explicitly specified, and consistent behaviour across\n            // Python versions, and most compact representation if indent is None\n            if (!indent) {\n                separators = [\",\", \":\"];\n            }\n            else {\n                separators = [\", \", \": \"];\n            }\n        }\n        this.#encoder_config = {\n            encoding,\n            skipkeys,\n            ensure_ascii,\n            check_circular,\n            allow_nan,\n            indent,\n            separators,\n            sort_keys,\n        };\n        this.#decoder_config = { strict };\n    }\n    static fromConfig(configuration) {\n        return new JsonCodec(configuration);\n    }\n    encode(buf) {\n        const { indent, encoding, ensure_ascii, check_circular, allow_nan, sort_keys, } = this.#encoder_config;\n        assert(encoding === \"utf-8\", \"JsonCodec does not yet support non-utf-8 encoding.\");\n        const replacer_functions = [];\n        // By default, for JSON.stringify,\n        // a TypeError will be thrown if one attempts to encode an object with circular references\n        assert(check_circular, \"JsonCodec does not yet support skipping the check for circular references during encoding.\");\n        if (!allow_nan) {\n            // Throw if NaN/Infinity/-Infinity are encountered during encoding.\n            replacer_functions.push(throw_on_nan_replacer);\n        }\n        if (sort_keys) {\n            // We can ensure keys are sorted but not really the opposite since\n            // there is no guarantee of key ordering in JS.\n            replacer_functions.push(sort_keys_replacer);\n        }\n        const items = Array.from(buf.data);\n        items.push(\"|O\");\n        items.push(buf.shape);\n        let replacer;\n        if (replacer_functions.length) {\n            replacer = (key, value) => {\n                let new_value = value;\n                for (let sub_replacer of replacer_functions) {\n                    new_value = sub_replacer(key, new_value);\n                }\n                return new_value;\n            };\n        }\n        let json_str = JSON.stringify(items, replacer, indent);\n        if (ensure_ascii) {\n            // If ensure_ascii is true (the default), the output is guaranteed\n            // to have all incoming non-ASCII characters escaped.\n            // If ensure_ascii is false, these characters will be output as-is.\n            // Reference: https://stackoverflow.com/a/31652607\n            json_str = json_str.replace(/[\\u007F-\\uFFFF]/g, (chr) => {\n                const full_str = `0000${chr.charCodeAt(0).toString(16)}`;\n                const sub_str = full_str.substring(full_str.length - 4);\n                return `\\\\u${sub_str}`;\n            });\n        }\n        return new TextEncoder().encode(json_str);\n    }\n    decode(bytes) {\n        const { strict } = this.#decoder_config;\n        // (i.e., allowing control characters inside strings)\n        assert(strict, \"JsonCodec does not yet support non-strict decoding.\");\n        const items = json_decode_object(bytes);\n        const shape = items.pop();\n        items.pop(); // Pop off dtype (unused)\n        // O-d case\n        assert(shape, \"0D not implemented for JsonCodec.\");\n        const stride = get_strides(shape, \"C\");\n        const data = items;\n        return { data, shape, stride };\n    }\n}\n//# sourceMappingURL=json2.js.map","import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"../typedarray.js\";\nimport { assert, get_strides } from \"../util.js\";\nfunction proxy(arr) {\n    if (arr instanceof BoolArray ||\n        arr instanceof ByteStringArray ||\n        arr instanceof UnicodeStringArray) {\n        // @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\n        const arrp = new Proxy(arr, {\n            get(target, prop) {\n                return target.get(Number(prop));\n            },\n            set(target, prop, value) {\n                // @ts-expect-error - value is OK\n                target.set(Number(prop), value);\n                return true;\n            },\n        });\n        return arrp;\n    }\n    // @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\n    return arr;\n}\nfunction empty_like(chunk, order) {\n    let data;\n    if (chunk.data instanceof ByteStringArray ||\n        chunk.data instanceof UnicodeStringArray) {\n        data = new chunk.constructor(\n        // @ts-expect-error\n        chunk.data.length, chunk.data.chars);\n    }\n    else {\n        data = new chunk.constructor(chunk.data.length);\n    }\n    return {\n        data,\n        shape: chunk.shape,\n        stride: get_strides(chunk.shape, order),\n    };\n}\nfunction convert_array_order(src, target) {\n    let out = empty_like(src, target);\n    let n_dims = src.shape.length;\n    let size = src.data.length;\n    let index = Array(n_dims).fill(0);\n    let src_data = proxy(src.data);\n    let out_data = proxy(out.data);\n    for (let src_idx = 0; src_idx < size; src_idx++) {\n        let out_idx = 0;\n        for (let dim = 0; dim < n_dims; dim++) {\n            out_idx += index[dim] * out.stride[dim];\n        }\n        out_data[out_idx] = src_data[src_idx];\n        index[0] += 1;\n        for (let dim = 0; dim < n_dims; dim++) {\n            if (index[dim] === src.shape[dim]) {\n                if (dim + 1 === n_dims) {\n                    break;\n                }\n                index[dim] = 0;\n                index[dim + 1] += 1;\n            }\n        }\n    }\n    return out;\n}\n/** Determine the memory order (axis permutation) for a chunk */\nfunction get_order(chunk) {\n    let rank = chunk.shape.length;\n    assert(rank === chunk.stride.length, \"Shape and stride must have the same length.\");\n    return chunk.stride\n        .map((s, i) => ({ stride: s, index: i }))\n        .sort((a, b) => b.stride - a.stride)\n        .map((entry) => entry.index);\n}\nfunction matches_order(chunk, target) {\n    let source = get_order(chunk);\n    assert(source.length === target.length, \"Orders must match\");\n    return source.every((dim, i) => dim === target[i]);\n}\nexport class TransposeCodec {\n    kind = \"array_to_array\";\n    #order;\n    #inverseOrder;\n    constructor(configuration, meta) {\n        let value = configuration.order ?? \"C\";\n        let rank = meta.shape.length;\n        let order = new Array(rank);\n        let inverseOrder = new Array(rank);\n        if (value === \"C\") {\n            for (let i = 0; i < rank; ++i) {\n                order[i] = i;\n                inverseOrder[i] = i;\n            }\n        }\n        else if (value === \"F\") {\n            for (let i = 0; i < rank; ++i) {\n                order[i] = rank - i - 1;\n                inverseOrder[i] = rank - i - 1;\n            }\n        }\n        else {\n            order = value;\n            order.forEach((x, i) => {\n                assert(inverseOrder[x] === undefined, `Invalid permutation: ${JSON.stringify(value)}`);\n                inverseOrder[x] = i;\n            });\n        }\n        this.#order = order;\n        this.#inverseOrder = inverseOrder;\n    }\n    static fromConfig(configuration, meta) {\n        return new TransposeCodec(configuration, meta);\n    }\n    encode(arr) {\n        if (matches_order(arr, this.#inverseOrder)) {\n            // can skip making a copy\n            return arr;\n        }\n        return convert_array_order(arr, this.#inverseOrder);\n    }\n    decode(arr) {\n        return {\n            data: arr.data,\n            shape: arr.shape,\n            stride: get_strides(arr.shape, this.#order),\n        };\n    }\n}\n//# sourceMappingURL=transpose.js.map","import { get_strides } from \"../util.js\";\nexport class VLenUTF8 {\n    kind = \"array_to_bytes\";\n    #shape;\n    #strides;\n    constructor(shape) {\n        this.#shape = shape;\n        this.#strides = get_strides(shape, \"C\");\n    }\n    static fromConfig(_, meta) {\n        return new VLenUTF8(meta.shape);\n    }\n    encode(_chunk) {\n        throw new Error(\"Method not implemented.\");\n    }\n    decode(bytes) {\n        let decoder = new TextDecoder();\n        let view = new DataView(bytes.buffer);\n        let data = Array(view.getUint32(0, true));\n        let pos = 4;\n        for (let i = 0; i < data.length; i++) {\n            let item_length = view.getUint32(pos, true);\n            pos += 4;\n            data[i] = decoder.decode(bytes.buffer.slice(pos, pos + item_length));\n            pos += item_length;\n        }\n        return { data, shape: this.#shape, stride: this.#strides };\n    }\n}\n//# sourceMappingURL=vlen-utf8.js.map","import { decompress } from \"../util.js\";\nexport class ZlibCodec {\n    kind = \"bytes_to_bytes\";\n    static fromConfig(_) {\n        return new ZlibCodec();\n    }\n    encode(_bytes) {\n        throw new Error(\"Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.\");\n    }\n    async decode(bytes) {\n        const buffer = await decompress(bytes, { format: \"deflate\" });\n        return new Uint8Array(buffer);\n    }\n}\n//# sourceMappingURL=zlib.js.map","import { BitroundCodec } from \"./codecs/bitround.js\";\nimport { BytesCodec } from \"./codecs/bytes.js\";\nimport { Crc32cCodec } from \"./codecs/crc32c.js\";\nimport { GzipCodec } from \"./codecs/gzip.js\";\nimport { JsonCodec } from \"./codecs/json2.js\";\nimport { TransposeCodec } from \"./codecs/transpose.js\";\nimport { VLenUTF8 } from \"./codecs/vlen-utf8.js\";\nimport { ZlibCodec } from \"./codecs/zlib.js\";\nimport { assert } from \"./util.js\";\nfunction create_default_registry() {\n    return new Map()\n        .set(\"blosc\", () => import(\"numcodecs/blosc\").then((m) => m.default))\n        .set(\"lz4\", () => import(\"numcodecs/lz4\").then((m) => m.default))\n        .set(\"zstd\", () => import(\"numcodecs/zstd\").then((m) => m.default))\n        .set(\"gzip\", () => GzipCodec)\n        .set(\"zlib\", () => ZlibCodec)\n        .set(\"transpose\", () => TransposeCodec)\n        .set(\"bytes\", () => BytesCodec)\n        .set(\"crc32c\", () => Crc32cCodec)\n        .set(\"vlen-utf8\", () => VLenUTF8)\n        .set(\"json2\", () => JsonCodec)\n        .set(\"bitround\", () => BitroundCodec);\n}\nexport const registry = create_default_registry();\nexport function create_codec_pipeline(chunk_metadata) {\n    let codecs;\n    return {\n        async encode(chunk) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (const codec of codecs.array_to_array) {\n                chunk = await codec.encode(chunk);\n            }\n            let bytes = await codecs.array_to_bytes.encode(chunk);\n            for (const codec of codecs.bytes_to_bytes) {\n                bytes = await codec.encode(bytes);\n            }\n            return bytes;\n        },\n        async decode(bytes) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {\n                bytes = await codecs.bytes_to_bytes[i].decode(bytes);\n            }\n            let chunk = await codecs.array_to_bytes.decode(bytes);\n            for (let i = codecs.array_to_array.length - 1; i >= 0; i--) {\n                chunk = await codecs.array_to_array[i].decode(chunk);\n            }\n            return chunk;\n        },\n    };\n}\nasync function load_codecs(chunk_meta) {\n    let promises = chunk_meta.codecs.map(async (meta) => {\n        let Codec = await registry.get(meta.name)?.();\n        assert(Codec, `Unknown codec: ${meta.name}`);\n        return { Codec, meta };\n    });\n    let array_to_array = [];\n    let array_to_bytes;\n    let bytes_to_bytes = [];\n    for await (let { Codec, meta } of promises) {\n        let codec = Codec.fromConfig(meta.configuration, chunk_meta);\n        switch (codec.kind) {\n            case \"array_to_array\":\n                array_to_array.push(codec);\n                break;\n            case \"array_to_bytes\":\n                array_to_bytes = codec;\n                break;\n            default:\n                bytes_to_bytes.push(codec);\n        }\n    }\n    if (!array_to_bytes) {\n        assert(is_typed_array_like_meta(chunk_meta), `Cannot encode ${chunk_meta.data_type} to bytes without a codec`);\n        array_to_bytes = BytesCodec.fromConfig({ endian: \"little\" }, chunk_meta);\n    }\n    return { array_to_array, array_to_bytes, bytes_to_bytes };\n}\nfunction is_typed_array_like_meta(meta) {\n    return meta.data_type !== \"v2:object\";\n}\n//# sourceMappingURL=codecs.js.map","import { create_codec_pipeline } from \"../codecs.js\";\nimport { assert } from \"../util.js\";\nconst MAX_BIG_UINT = 18446744073709551615n;\nexport function create_sharded_chunk_getter(location, shard_shape, encode_shard_key, sharding_config) {\n    assert(location.store.getRange, \"Store does not support range requests\");\n    let get_range = location.store.getRange.bind(location.store);\n    let index_shape = shard_shape.map((d, i) => d / sharding_config.chunk_shape[i]);\n    let index_codec = create_codec_pipeline({\n        data_type: \"uint64\",\n        shape: [...index_shape, 2],\n        codecs: sharding_config.index_codecs,\n    });\n    let cache = {};\n    return async (chunk_coord) => {\n        let shard_coord = chunk_coord.map((d, i) => Math.floor(d / index_shape[i]));\n        let shard_path = location.resolve(encode_shard_key(shard_coord)).path;\n        let index;\n        if (shard_path in cache) {\n            index = cache[shard_path];\n        }\n        else {\n            let checksum_size = 4;\n            let index_size = 16 * index_shape.reduce((a, b) => a * b, 1);\n            let bytes = await get_range(shard_path, {\n                suffixLength: index_size + checksum_size,\n            });\n            index = cache[shard_path] = bytes\n                ? await index_codec.decode(bytes)\n                : null;\n        }\n        if (index === null) {\n            return undefined;\n        }\n        let { data, shape, stride } = index;\n        let linear_offset = chunk_coord\n            .map((d, i) => d % shape[i])\n            .reduce((acc, sel, idx) => acc + sel * stride[idx], 0);\n        let offset = data[linear_offset];\n        let length = data[linear_offset + 1];\n        // write null chunk when 2^64-1 indicates fill value\n        if (offset === MAX_BIG_UINT && length === MAX_BIG_UINT) {\n            return undefined;\n        }\n        return get_range(shard_path, {\n            offset: Number(offset),\n            length: Number(length),\n        });\n    };\n}\n//# sourceMappingURL=sharding.js.map","import { create_sharded_chunk_getter } from \"./codecs/sharding.js\";\nimport { create_codec_pipeline } from \"./codecs.js\";\nimport { create_chunk_key_encoder, ensure_correct_scalar, get_ctr, get_strides, is_dtype, is_sharding_codec, } from \"./util.js\";\nexport class Location {\n    store;\n    path;\n    constructor(store, path = \"/\") {\n        this.store = store;\n        this.path = path;\n    }\n    resolve(path) {\n        // reuse URL resolution logic built into the browser\n        // handles relative paths, absolute paths, etc.\n        let root = new URL(`file://${this.path.endsWith(\"/\") ? this.path : `${this.path}/`}`);\n        return new Location(this.store, decodeURIComponent(new URL(path, root).pathname));\n    }\n}\nexport function root(store) {\n    return new Location(store ?? new Map());\n}\nexport class Group extends Location {\n    kind = \"group\";\n    #metadata;\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = metadata;\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n}\nfunction get_array_order(codecs) {\n    const maybe_transpose_codec = codecs.find((c) => c.name === \"transpose\");\n    // @ts-expect-error - TODO: Should validate?\n    return maybe_transpose_codec?.configuration?.order ?? \"C\";\n}\nconst CONTEXT_MARKER = Symbol(\"zarrita.context\");\nexport function get_context(obj) {\n    return obj[CONTEXT_MARKER];\n}\nfunction create_context(location, metadata) {\n    let { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};\n    let shared_context = {\n        encode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),\n        TypedArray: get_ctr(metadata.data_type),\n        fill_value: metadata.fill_value,\n    };\n    if (configuration) {\n        let native_order = get_array_order(configuration.codecs);\n        return {\n            ...shared_context,\n            kind: \"sharded\",\n            chunk_shape: configuration.chunk_shape,\n            codec: create_codec_pipeline({\n                data_type: metadata.data_type,\n                shape: configuration.chunk_shape,\n                codecs: configuration.codecs,\n            }),\n            get_strides(shape) {\n                return get_strides(shape, native_order);\n            },\n            get_chunk_bytes: create_sharded_chunk_getter(location, metadata.chunk_grid.configuration.chunk_shape, shared_context.encode_chunk_key, configuration),\n        };\n    }\n    let native_order = get_array_order(metadata.codecs);\n    return {\n        ...shared_context,\n        kind: \"regular\",\n        chunk_shape: metadata.chunk_grid.configuration.chunk_shape,\n        codec: create_codec_pipeline({\n            data_type: metadata.data_type,\n            shape: metadata.chunk_grid.configuration.chunk_shape,\n            codecs: metadata.codecs,\n        }),\n        get_strides(shape) {\n            return get_strides(shape, native_order);\n        },\n        async get_chunk_bytes(chunk_coords, options) {\n            let chunk_key = shared_context.encode_chunk_key(chunk_coords);\n            let chunk_path = location.resolve(chunk_key).path;\n            return location.store.get(chunk_path, options);\n        },\n    };\n}\nexport class Array extends Location {\n    kind = \"array\";\n    #metadata;\n    [CONTEXT_MARKER];\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = {\n            ...metadata,\n            fill_value: ensure_correct_scalar(metadata),\n        };\n        this[CONTEXT_MARKER] = create_context(this, metadata);\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n    get shape() {\n        return this.#metadata.shape;\n    }\n    get chunks() {\n        return this[CONTEXT_MARKER].chunk_shape;\n    }\n    get dtype() {\n        return this.#metadata.data_type;\n    }\n    async getChunk(chunk_coords, options) {\n        let context = this[CONTEXT_MARKER];\n        let maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);\n        if (!maybe_bytes) {\n            let size = context.chunk_shape.reduce((a, b) => a * b, 1);\n            let data = new context.TypedArray(size);\n            // @ts-expect-error: TS can't infer that `fill_value` is union (assumes never) but this is ok\n            data.fill(context.fill_value);\n            return {\n                data,\n                shape: context.chunk_shape,\n                stride: context.get_strides(context.chunk_shape),\n            };\n        }\n        return context.codec.decode(maybe_bytes);\n    }\n    /**\n     * A helper method to narrow `zarr.Array` Dtype.\n     *\n     * ```typescript\n     * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: \"array\" });\n     *\n     * // Option 1: narrow by scalar type (e.g. \"bool\", \"raw\", \"bigint\", \"number\")\n     * if (arr.is(\"bigint\")) {\n     *   // zarr.Array<\"int64\" | \"uint64\", FetchStore>\n     * }\n     *\n     * // Option 3: exact match\n     * if (arr.is(\"float32\")) {\n     *   // zarr.Array<\"float32\", FetchStore, \"/\">\n     * }\n     * ```\n     */\n    is(query) {\n        return is_dtype(this.dtype, query);\n    }\n}\n//# sourceMappingURL=hierarchy.js.map","/** Similar to python's `range` function. Supports positive ranges only. */\nexport function* range(start, stop, step = 1) {\n    if (stop === undefined) {\n        stop = start;\n        start = 0;\n    }\n    for (let i = start; i < stop; i += step) {\n        yield i;\n    }\n}\n/**\n * python-like itertools.product generator\n * https://gist.github.com/cybercase/db7dde901d7070c98c48\n */\nexport function* product(...iterables) {\n    if (iterables.length === 0) {\n        return;\n    }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map((it) => it[Symbol.iterator]());\n    const results = iterators.map((it) => it.next());\n    if (results.some((r) => r.done)) {\n        throw new Error(\"Input contains an empty iterator.\");\n    }\n    for (let i = 0;;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i][Symbol.iterator]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) {\n                return;\n            }\n        }\n        else {\n            // @ts-expect-error - TS can't infer this\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n// https://github.com/python/cpython/blob/263c0dd16017613c5ea2fbfc270be4de2b41b5ad/Objects/sliceobject.c#L376-L519\nexport function slice_indices({ start, stop, step }, length) {\n    if (step === 0) {\n        throw new Error(\"slice step cannot be zero\");\n    }\n    step = step ?? 1;\n    const step_is_negative = step < 0;\n    /* Find lower and upper bounds for start and stop. */\n    const [lower, upper] = step_is_negative ? [-1, length - 1] : [0, length];\n    /* Compute start. */\n    if (start === null) {\n        start = step_is_negative ? upper : lower;\n    }\n    else {\n        if (start < 0) {\n            start += length;\n            if (start < lower) {\n                start = lower;\n            }\n        }\n        else if (start > upper) {\n            start = upper;\n        }\n    }\n    /* Compute stop. */\n    if (stop === null) {\n        stop = step_is_negative ? lower : upper;\n    }\n    else {\n        if (stop < 0) {\n            stop += length;\n            if (stop < lower) {\n                stop = lower;\n            }\n        }\n        else if (stop > upper) {\n            stop = upper;\n        }\n    }\n    return [start, stop, step];\n}\nexport function slice(start, stop, step = null) {\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n    return {\n        start,\n        stop,\n        step,\n    };\n}\n/** Built-in \"queue\" for awaiting promises. */\nexport function create_queue() {\n    const promises = [];\n    return {\n        add: (fn) => promises.push(fn()),\n        onIdle: () => Promise.all(promises),\n    };\n}\n//# sourceMappingURL=util.js.map","import { product, range, slice, slice_indices } from \"./util.js\";\nexport class IndexError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = \"IndexError\";\n    }\n}\nfunction err_too_many_indices(selection, shape) {\n    throw new IndexError(`too many indicies for array; expected ${shape.length}, got ${selection.length}`);\n}\nfunction err_boundscheck(dim_len) {\n    throw new IndexError(`index out of bounds for dimension with length ${dim_len}`);\n}\nfunction err_negative_step() {\n    throw new IndexError(\"only slices with step >= 1 are supported\");\n}\nfunction check_selection_length(selection, shape) {\n    if (selection.length > shape.length) {\n        err_too_many_indices(selection, shape);\n    }\n}\nexport function normalize_integer_selection(dim_sel, dim_len) {\n    // normalize type to int\n    dim_sel = Math.trunc(dim_sel);\n    // handle wraparound\n    if (dim_sel < 0) {\n        dim_sel = dim_len + dim_sel;\n    }\n    // handle out of bounds\n    if (dim_sel >= dim_len || dim_sel < 0) {\n        err_boundscheck(dim_len);\n    }\n    return dim_sel;\n}\nclass IntDimIndexer {\n    dim_sel;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        dim_sel = normalize_integer_selection(dim_sel, dim_len);\n        // store properties\n        this.dim_sel = dim_sel;\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = 1;\n    }\n    *[Symbol.iterator]() {\n        const dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);\n        const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n        const dim_chunk_sel = this.dim_sel - dim_offset;\n        yield { dim_chunk_ix, dim_chunk_sel };\n    }\n}\nclass SliceDimIndexer {\n    start;\n    stop;\n    step;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    nchunks;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        const [start, stop, step] = slice_indices(dim_sel, dim_len);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1)\n            err_negative_step();\n        // store properties\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);\n    }\n    *[Symbol.iterator]() {\n        // figure out the range of chunks we need to visit\n        const dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);\n        const dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);\n        for (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {\n            // compute offsets for chunk within overall array\n            const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n            const dim_limit = Math.min(this.dim_len, (dim_chunk_ix + 1) * this.dim_chunk_len);\n            // determine chunk length, accounting for trailing chunk\n            const dim_chunk_len = dim_limit - dim_offset;\n            let dim_out_offset = 0;\n            let dim_chunk_sel_start = 0;\n            if (this.start < dim_offset) {\n                // selection start before current chunk\n                const remainder = (dim_offset - this.start) % this.step;\n                if (remainder)\n                    dim_chunk_sel_start += this.step - remainder;\n                // compute number of previous items, provides offset into output array\n                dim_out_offset = Math.ceil((dim_offset - this.start) / this.step);\n            }\n            else {\n                // selection starts within current chunk\n                dim_chunk_sel_start = this.start - dim_offset;\n            }\n            // selection starts within current chunk if true,\n            // otherwise selection ends after current chunk.\n            const dim_chunk_sel_stop = this.stop > dim_limit ? dim_chunk_len : this.stop - dim_offset;\n            const dim_chunk_sel = [\n                dim_chunk_sel_start,\n                dim_chunk_sel_stop,\n                this.step,\n            ];\n            const dim_chunk_nitems = Math.ceil((dim_chunk_sel_stop - dim_chunk_sel_start) / this.step);\n            const dim_out_sel = [\n                dim_out_offset,\n                dim_out_offset + dim_chunk_nitems,\n                1,\n            ];\n            yield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };\n        }\n    }\n}\nexport function normalize_selection(selection, shape) {\n    let normalized = [];\n    if (selection === null) {\n        normalized = shape.map((_) => slice(null));\n    }\n    else if (Array.isArray(selection)) {\n        normalized = selection.map((s) => s ?? slice(null));\n    }\n    check_selection_length(normalized, shape);\n    return normalized;\n}\nexport class BasicIndexer {\n    dim_indexers;\n    shape;\n    constructor({ selection, shape, chunk_shape }) {\n        // setup per-dimension indexers\n        this.dim_indexers = normalize_selection(selection, shape).map((dim_sel, i) => {\n            return new (typeof dim_sel === \"number\" ? IntDimIndexer : SliceDimIndexer)({\n                // @ts-expect-error ts inference not strong enough to know correct chunk\n                dim_sel: dim_sel,\n                dim_len: shape[i],\n                dim_chunk_len: chunk_shape[i],\n            });\n        });\n        this.shape = this.dim_indexers\n            .filter((ixr) => ixr instanceof SliceDimIndexer)\n            .map((sixr) => sixr.nitems);\n    }\n    *[Symbol.iterator]() {\n        for (const dim_projections of product(...this.dim_indexers)) {\n            const chunk_coords = dim_projections.map((p) => p.dim_chunk_ix);\n            const mapping = dim_projections.map((p) => {\n                if (\"dim_out_sel\" in p) {\n                    return { from: p.dim_chunk_sel, to: p.dim_out_sel };\n                }\n                return { from: p.dim_chunk_sel, to: null };\n            });\n            yield { chunk_coords, mapping };\n        }\n    }\n}\n//# sourceMappingURL=indexer.js.map","import { get as get_with_setter } from \"./get.js\";\nimport { set as set_with_setter } from \"./set.js\";\n/** A 1D \"view\" of an array that can be used to set values in the array. */\nfunction object_array_view(arr, offset = 0, size) {\n    let length = size ?? arr.length - offset;\n    return {\n        length,\n        subarray(from, to = length) {\n            return object_array_view(arr, offset + from, to - from);\n        },\n        set(data, start = 0) {\n            for (let i = 0; i < data.length; i++) {\n                arr[offset + start + i] = data.get(i);\n            }\n        },\n        get(index) {\n            return arr[offset + index];\n        },\n    };\n}\n/**\n * Convert a chunk to a Uint8Array that can be used with the binary\n * set functions. This is necessary because the binary set functions\n * require a contiguous block of memory, and allows us to support more than\n * just the browser's TypedArray objects.\n *\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\n * In the case of `Array` instances, it will return a `object_array_view` of\n * the underlying, which is supported by our binary set functions.\n */\nfunction compat_chunk(arr) {\n    if (globalThis.Array.isArray(arr.data)) {\n        return {\n            // @ts-expect-error\n            data: object_array_view(arr.data),\n            stride: arr.stride,\n            bytes_per_element: 1,\n        };\n    }\n    return {\n        data: new Uint8Array(arr.data.buffer, arr.data.byteOffset, arr.data.byteLength),\n        stride: arr.stride,\n        bytes_per_element: arr.data.BYTES_PER_ELEMENT,\n    };\n}\n/** Hack to get the constructor of a typed array constructor from an existing TypedArray. */\nfunction get_typed_array_constructor(arr) {\n    if (\"chars\" in arr) {\n        // our custom TypedArray needs to bind the number of characters per\n        // element to the constructor.\n        return arr.constructor.bind(null, arr.chars);\n    }\n    return arr.constructor;\n}\n/**\n * Convert a scalar to a Uint8Array that can be used with the binary\n * set functions. This is necessary because the binary set functions\n * require a contiguous block of memory, and allows us to support more\n * than just the browser's TypedArray objects.\n *\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\n * In the case of `Array` instances, it will return a `object_array_view` of\n * the scalar, which is supported by our binary set functions.\n */\nfunction compat_scalar(arr, value) {\n    if (globalThis.Array.isArray(arr.data)) {\n        // @ts-expect-error\n        return object_array_view([value]);\n    }\n    let TypedArray = get_typed_array_constructor(arr.data);\n    // @ts-expect-error - value is a scalar and matches\n    let data = new TypedArray([value]);\n    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n}\nexport const setter = {\n    prepare(data, shape, stride) {\n        return { data, shape, stride };\n    },\n    set_scalar(dest, sel, value) {\n        let view = compat_chunk(dest);\n        set_scalar_binary(view, sel, compat_scalar(dest, value), view.bytes_per_element);\n    },\n    set_from_chunk(dest, src, projections) {\n        let view = compat_chunk(dest);\n        set_from_chunk_binary(view, compat_chunk(src), view.bytes_per_element, projections);\n    },\n};\n/** @category Utility */\nexport async function get(arr, selection = null, opts = {}) {\n    return get_with_setter(arr, selection, opts, setter);\n}\n/** @category Utility */\nexport async function set(arr, selection, value, opts = {}) {\n    return set_with_setter(arr, selection, value, opts, setter);\n}\nfunction indices_len(start, stop, step) {\n    if (step < 0 && stop < start) {\n        return Math.floor((start - stop - 1) / -step) + 1;\n    }\n    if (start < stop)\n        return Math.floor((stop - start - 1) / step) + 1;\n    return 0;\n}\nfunction set_scalar_binary(out, out_selection, value, bytes_per_element) {\n    if (out_selection.length === 0) {\n        out.data.set(value, 0);\n        return;\n    }\n    const [slice, ...slices] = out_selection;\n    const [curr_stride, ...stride] = out.stride;\n    if (typeof slice === \"number\") {\n        const data = out.data.subarray(curr_stride * slice * bytes_per_element);\n        set_scalar_binary({ data, stride }, slices, value, bytes_per_element);\n        return;\n    }\n    const [from, to, step] = slice;\n    const len = indices_len(from, to, step);\n    if (slices.length === 0) {\n        for (let i = 0; i < len; i++) {\n            out.data.set(value, curr_stride * (from + step * i) * bytes_per_element);\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        const data = out.data.subarray(curr_stride * (from + step * i) * bytes_per_element);\n        set_scalar_binary({ data, stride }, slices, value, bytes_per_element);\n    }\n}\nfunction set_from_chunk_binary(dest, src, bytes_per_element, projections) {\n    const [proj, ...projs] = projections;\n    const [dstride, ...dstrides] = dest.stride;\n    const [sstride, ...sstrides] = src.stride;\n    if (proj.from === null) {\n        if (projs.length === 0) {\n            dest.data.set(src.data.subarray(0, bytes_per_element), proj.to * bytes_per_element);\n            return;\n        }\n        set_from_chunk_binary({\n            data: dest.data.subarray(dstride * proj.to * bytes_per_element),\n            stride: dstrides,\n        }, src, bytes_per_element, projs);\n        return;\n    }\n    if (proj.to === null) {\n        if (projs.length === 0) {\n            let offset = proj.from * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + bytes_per_element), 0);\n            return;\n        }\n        set_from_chunk_binary(dest, {\n            data: src.data.subarray(sstride * proj.from * bytes_per_element),\n            stride: sstrides,\n        }, bytes_per_element, projs);\n        return;\n    }\n    const [from, to, step] = proj.to;\n    const [sfrom, _, sstep] = proj.from;\n    const len = indices_len(from, to, step);\n    if (projs.length === 0) {\n        // NB: we have a contiguous block of memory\n        // so we can just copy over all the data at once.\n        if (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {\n            let offset = sfrom * bytes_per_element;\n            let size = len * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + size), from * bytes_per_element);\n            return;\n        }\n        // Otherwise, we have to copy over each element individually.\n        for (let i = 0; i < len; i++) {\n            let offset = sstride * (sfrom + sstep * i) * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + bytes_per_element), dstride * (from + step * i) * bytes_per_element);\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        set_from_chunk_binary({\n            data: dest.data.subarray(dstride * (from + i * step) * bytes_per_element),\n            stride: dstrides,\n        }, {\n            data: src.data.subarray(sstride * (sfrom + i * sstep) * bytes_per_element),\n            stride: sstrides,\n        }, bytes_per_element, projs);\n    }\n}\n//# sourceMappingURL=ops.js.map","import { get_context } from \"../hierarchy.js\";\nimport { BasicIndexer } from \"./indexer.js\";\nimport { create_queue } from \"./util.js\";\nfunction unwrap(arr, idx) {\n    return (\"get\" in arr ? arr.get(idx) : arr[idx]);\n}\nexport async function get(arr, selection, opts, setter) {\n    let context = get_context(arr);\n    let indexer = new BasicIndexer({\n        selection,\n        shape: arr.shape,\n        chunk_shape: arr.chunks,\n    });\n    let out = setter.prepare(new context.TypedArray(indexer.shape.reduce((a, b) => a * b, 1)), indexer.shape, context.get_strides(indexer.shape));\n    let queue = opts.create_queue?.() ?? create_queue();\n    for (const { chunk_coords, mapping } of indexer) {\n        queue.add(async () => {\n            let { data, shape, stride } = await arr.getChunk(chunk_coords, opts.opts);\n            let chunk = setter.prepare(data, shape, stride);\n            setter.set_from_chunk(out, chunk, mapping);\n        });\n    }\n    await queue.onIdle();\n    // If the final out shape is empty, we just return a scalar.\n    // @ts-expect-error - TS can't narrow this conditional type\n    return indexer.shape.length === 0 ? unwrap(out.data, 0) : out;\n}\n//# sourceMappingURL=get.js.map","import { getChunks, mustCreateBuffer, mustCreateTexture, ChunkTuple } from \"./utils\";\nimport * as zarr from \"zarrita\";\nimport type { Array, DataType } from \"zarrita\";\nimport type { Readable } from \"@zarrita/storage\";\n\nexport type Loader = Array<DataType, Readable>;\n\ninterface TileProps {\n  chunk: ChunkTuple;\n  chunks: number[];\n  loader: Loader;\n\n  dimensions: string[];\n  shape: number[];\n  dimArrs: Record<string, number[]>;\n\n  gl: WebGL2RenderingContext;\n\n  z: number;\n  x: number;\n  y: number;\n}\n\nclass Tile {\n  chunk: ChunkTuple;\n  chunks: number[];\n  loader: Loader;\n\n  dimensions: string[];\n  shape: number[];\n  dimArrs: Record<string, number[]>;\n  data: Float32Array | null = null;\n  dataCache: Record<string, Float32Array | null>;\n\n  z: number;\n  x: number;\n  y: number;\n\n  loading: boolean = false;\n  loadingPromise: Promise<Float32Array> | null = null;\n\n  tileTexture: WebGLTexture;\n  vertexBuffer: WebGLBuffer;\n  pixCoordBuffer: WebGLBuffer;\n\n  constructor({ chunk, chunks, loader, dimensions, shape, dimArrs, z, x, y, gl }: TileProps) {\n    this.chunk = chunk;\n    this.chunks = chunks;\n    this.loader = loader;\n\n    this.dimensions = dimensions;\n    this.shape = shape;\n    this.dimArrs = dimArrs;\n    this.dataCache = {};\n\n    this.z = z;\n    this.x = x;\n    this.y = y;\n\n    this.tileTexture = mustCreateTexture(gl);\n    this.vertexBuffer = mustCreateBuffer(gl);\n    this.pixCoordBuffer = mustCreateBuffer(gl);\n  }\n\n  async fetchData(selector: Record<string, number>): Promise<Float32Array> {\n    const neededChunks = getChunks({\n      selector,\n      dimensions: this.dimensions,\n      dimArrs: this.dimArrs,\n      shape: this.shape,\n      chunks: this.chunks,\n      x: this.x,\n      y: this.y,\n    });\n    const chunk = neededChunks[0];\n    if (neededChunks.length !== 1 || !chunk) {\n      throw new Error(\"Need exactly one chunk per tile\");\n    }\n    const chunkKey = chunk.join(\",\");\n    if (this.dataCache[chunkKey]) {\n      this.data = this.dataCache[chunkKey];\n      return this.data;\n    } else if (this.loadingPromise) {\n      // If already loading, return the existing promise\n      return this.loadingPromise;\n    }\n\n    this.loadingPromise = (async () => {\n      this.loading = true;\n      const indexIntoChunk = this.dimensions.map((d) => {\n        if ([\"x\", \"y\"].includes(d)) {\n          return null;\n        } else if (selector[d] === undefined) {\n          return null;\n        } else {\n          const idx = this.dimArrs[d]?.findIndex((coordinate) => coordinate === selector[d]);\n          if (typeof idx === \"undefined\") {\n            throw new Error(\"Couldnt extract indices from dimArrs\");\n          }\n          return idx;\n        }\n      });\n\n      // Use zarrita's get method instead of callback-based loader\n      // zarr.get returns a Chunk with {data, shape, stride} and pick method\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const data: any = await zarr.get(this.loader, chunk);\n      this.loading = false;\n      this.loadingPromise = null;\n\n      const d = data.pick(...indexIntoChunk);\n      this.data = d.data as Float32Array;\n      this.dataCache[chunkKey] = this.data;\n      return this.data;\n    })();\n\n    return this.loadingPromise;\n  }\n\n  getDimension(dimension: string): number | undefined {\n    const index = this.dimensions.indexOf(dimension);\n    if (index === -1) {\n      return undefined;\n    }\n    return this.chunks[index];\n  }\n}\n\nexport default Tile;\n","export function strip_prefix(path) {\n    // @ts-expect-error - TS can't infer this type correctly\n    return path.slice(1);\n}\nexport function uri2href(url) {\n    let [protocol, rest] = (typeof url === \"string\" ? url : url.href).split(\"://\");\n    if (protocol === \"https\" || protocol === \"http\") {\n        return url;\n    }\n    if (protocol === \"gc\") {\n        return `https://storage.googleapis.com/${rest}`;\n    }\n    if (protocol === \"s3\") {\n        return `https://s3.amazonaws.com/${rest}`;\n    }\n    throw Error(`Protocol not supported, got: ${JSON.stringify(protocol)}`);\n}\nexport function fetch_range(url, offset, length, opts = {}) {\n    if (offset !== undefined && length !== undefined) {\n        // merge request opts\n        opts = {\n            ...opts,\n            headers: {\n                ...opts.headers,\n                Range: `bytes=${offset}-${offset + length - 1}`,\n            },\n        };\n    }\n    return fetch(url, opts);\n}\nexport function merge_init(storeOverrides, requestOverrides) {\n    // Request overrides take precedence over storeOverrides.\n    return {\n        ...storeOverrides,\n        ...requestOverrides,\n        headers: {\n            ...storeOverrides.headers,\n            ...requestOverrides.headers,\n        },\n    };\n}\n/**\n * Make an assertion.\n *\n * Usage\n * @example\n * ```ts\n * const value: boolean = Math.random() <= 0.5;\n * assert(value, \"value is greater than than 0.5!\");\n * value // true\n * ```\n *\n * @param expression - The expression to test.\n * @param msg - The optional message to display if the assertion fails.\n * @throws an {@link Error} if `expression` is not truthy.\n */\nexport function assert(expression, msg = \"\") {\n    if (!expression)\n        throw new Error(msg);\n}\n//# sourceMappingURL=util.js.map","import { fetch_range, merge_init } from \"./util.js\";\nfunction resolve(root, path) {\n    const base = typeof root === \"string\" ? new URL(root) : root;\n    if (!base.pathname.endsWith(\"/\")) {\n        // ensure trailing slash so that base is resolved as _directory_\n        base.pathname += \"/\";\n    }\n    const resolved = new URL(path.slice(1), base);\n    // copy search params to new URL\n    resolved.search = base.search;\n    return resolved;\n}\nasync function handle_response(response) {\n    if (response.status === 404) {\n        return undefined;\n    }\n    if (response.status === 200 || response.status === 206) {\n        return new Uint8Array(await response.arrayBuffer());\n    }\n    throw new Error(`Unexpected response status ${response.status} ${response.statusText}`);\n}\nasync function fetch_suffix(url, suffix_length, init, use_suffix_request) {\n    if (use_suffix_request) {\n        return fetch(url, {\n            ...init,\n            headers: { ...init.headers, Range: `bytes=-${suffix_length}` },\n        });\n    }\n    let response = await fetch(url, { ...init, method: \"HEAD\" });\n    if (!response.ok) {\n        // will be picked up by handle_response\n        return response;\n    }\n    let content_length = response.headers.get(\"Content-Length\");\n    let length = Number(content_length);\n    return fetch_range(url, length - suffix_length, length, init);\n}\n/**\n * Readonly store based in the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n * Must polyfill `fetch` for use in Node.js.\n *\n * ```typescript\n * import * as zarr from \"zarrita\";\n * const store = new FetchStore(\"http://localhost:8080/data.zarr\");\n * const arr = await zarr.get(store, { kind: \"array\" });\n * ```\n */\nclass FetchStore {\n    url;\n    #overrides;\n    #use_suffix_request;\n    constructor(url, options = {}) {\n        this.url = url;\n        this.#overrides = options.overrides ?? {};\n        this.#use_suffix_request = options.useSuffixRequest ?? false;\n    }\n    #merge_init(overrides) {\n        return merge_init(this.#overrides, overrides);\n    }\n    async get(key, options = {}) {\n        let href = resolve(this.url, key).href;\n        let response = await fetch(href, this.#merge_init(options));\n        return handle_response(response);\n    }\n    async getRange(key, range, options = {}) {\n        let url = resolve(this.url, key);\n        let init = this.#merge_init(options);\n        let response;\n        if (\"suffixLength\" in range) {\n            response = await fetch_suffix(url, range.suffixLength, init, this.#use_suffix_request);\n        }\n        else {\n            response = await fetch_range(url, range.offset, range.length, init);\n        }\n        return handle_response(response);\n    }\n}\nexport default FetchStore;\n//# sourceMappingURL=fetch.js.map","export class NodeNotFoundError extends Error {\n    constructor(context, options = {}) {\n        super(`Node not found: ${context}`, options);\n        this.name = \"NodeNotFoundError\";\n    }\n}\nexport class KeyError extends Error {\n    constructor(path) {\n        super(`Missing key: ${path}`);\n        this.name = \"KeyError\";\n    }\n}\n//# sourceMappingURL=errors.js.map","import { KeyError, NodeNotFoundError } from \"./errors.js\";\nimport { Array, Group, Location } from \"./hierarchy.js\";\nimport { ensure_correct_scalar, json_decode_object, rethrow_unless, v2_to_v3_array_metadata, v2_to_v3_group_metadata, } from \"./util.js\";\nlet VERSION_COUNTER = create_version_counter();\nfunction create_version_counter() {\n    let version_counts = new WeakMap();\n    function get_counts(store) {\n        let counts = version_counts.get(store) ?? { v2: 0, v3: 0 };\n        version_counts.set(store, counts);\n        return counts;\n    }\n    return {\n        increment(store, version) {\n            get_counts(store)[version] += 1;\n        },\n        version_max(store) {\n            let counts = get_counts(store);\n            return counts.v3 > counts.v2 ? \"v3\" : \"v2\";\n        },\n    };\n}\nasync function load_attrs(location) {\n    let meta_bytes = await location.store.get(location.resolve(\".zattrs\").path);\n    if (!meta_bytes)\n        return {};\n    return json_decode_object(meta_bytes);\n}\nasync function open_v2(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let attrs = {};\n    if (options.attrs ?? true)\n        attrs = await load_attrs(loc);\n    if (options.kind === \"array\")\n        return open_array_v2(loc, attrs);\n    if (options.kind === \"group\")\n        return open_group_v2(loc, attrs);\n    return open_array_v2(loc, attrs).catch((err) => {\n        rethrow_unless(err, NodeNotFoundError);\n        return open_group_v2(loc, attrs);\n    });\n}\nasync function open_array_v2(location, attrs) {\n    let { path } = location.resolve(\".zarray\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v2 array\", {\n            cause: new KeyError(path),\n        });\n    }\n    VERSION_COUNTER.increment(location.store, \"v2\");\n    return new Array(location.store, location.path, v2_to_v3_array_metadata(json_decode_object(meta), attrs));\n}\nasync function open_group_v2(location, attrs) {\n    let { path } = location.resolve(\".zgroup\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v2 group\", {\n            cause: new KeyError(path),\n        });\n    }\n    VERSION_COUNTER.increment(location.store, \"v2\");\n    return new Group(location.store, location.path, v2_to_v3_group_metadata(json_decode_object(meta), attrs));\n}\nasync function _open_v3(location) {\n    let { store, path } = location.resolve(\"zarr.json\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v3 array or group\", {\n            cause: new KeyError(path),\n        });\n    }\n    let meta_doc = json_decode_object(meta);\n    if (meta_doc.node_type === \"array\") {\n        meta_doc.fill_value = ensure_correct_scalar(meta_doc);\n    }\n    return meta_doc.node_type === \"array\"\n        ? new Array(store, location.path, meta_doc)\n        : new Group(store, location.path, meta_doc);\n}\nasync function open_v3(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let node = await _open_v3(loc);\n    VERSION_COUNTER.increment(loc.store, \"v3\");\n    if (options.kind === undefined)\n        return node;\n    if (options.kind === \"array\" && node instanceof Array)\n        return node;\n    if (options.kind === \"group\" && node instanceof Group)\n        return node;\n    let kind = node instanceof Array ? \"array\" : \"group\";\n    throw new Error(`Expected node of kind ${options.kind}, found ${kind}.`);\n}\nexport async function open(location, options = {}) {\n    let store = \"store\" in location ? location.store : location;\n    let version_max = VERSION_COUNTER.version_max(store);\n    // Use the open function for the version with the most successful opens.\n    // Note that here we use the dot syntax to access the open functions\n    // because this enables us to use vi.spyOn during testing.\n    let open_primary = version_max === \"v2\" ? open.v2 : open.v3;\n    let open_secondary = version_max === \"v2\" ? open.v3 : open.v2;\n    return open_primary(location, options).catch((err) => {\n        rethrow_unless(err, NodeNotFoundError);\n        return open_secondary(location, options);\n    });\n}\nopen.v2 = open_v2;\nopen.v3 = open_v3;\n//# sourceMappingURL=open.js.map","// This code adapted from:\n// https://github.com/carbonplan/maps\n// With the following license:\n// MIT License\n// Copyright (c) 2021 carbonplan\n\nimport * as zarr from \"zarrita\";\n\nexport interface MultiscaleDataset {\n  path: string;\n  pixels_per_tile?: number;\n  crs?: string;\n}\n\nexport interface Multiscale {\n  datasets: MultiscaleDataset[];\n}\n\nexport interface RequestParameters {\n  url: string;\n  headers?: { [key: string]: string };\n  credentials?: RequestCredentials;\n}\n\nconst createFetchStore = (\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>,\n) => {\n  if (!transformRequest) {\n    return (url: string) => new zarr.FetchStore(url);\n  }\n\n  return async (url: string) => {\n    const requestParams = await transformRequest(url);\n    return new zarr.FetchStore(requestParams.url, {\n      overrides: {\n        headers: requestParams.headers,\n        credentials: requestParams.credentials,\n      },\n    });\n  };\n};\n\nconst getPyramidMetadata = (multiscales: Multiscale[]) => {\n  const datasets = multiscales[0]?.datasets;\n  if (!datasets) {\n    throw new Error(\"No `multiscales` or `datasets` in zarr metadata\");\n  }\n  const levels = datasets.map((dataset) => Number(dataset.path));\n  const maxZoom = Math.max(...levels);\n  const tileSize = datasets[0]?.pixels_per_tile;\n  const crs = datasets[0]?.crs ?? \"EPSG:3857\";\n  if (!tileSize) {\n    throw new Error(\"No `pixels_per_tile` value in `multiscales` metadata.\");\n  }\n  return { levels, maxZoom, tileSize, crs };\n};\n\nconst loadZarrV2 = async (\n  source: string,\n  variable: string,\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>,\n) => {\n  const createStore = createFetchStore(transformRequest);\n  const store = await createStore(source);\n\n  const grp = await zarr.open.v2(store, { kind: \"group\" });\n  const rootAttrs = grp.attrs as Record<string, unknown>;\n  const multiscales = rootAttrs.multiscales as Multiscale[];\n  const { levels, maxZoom, tileSize, crs } = getPyramidMetadata(multiscales);\n\n  // Use zarr.root() to create a Location, then resolve paths\n  const location = zarr.root(store);\n  const array = await zarr.open(location.resolve(`${levels[0]}/${variable}`), {\n    kind: \"array\",\n  });\n\n  const arrayAttrs = array.attrs as Record<string, unknown>;\n  const dimensions = arrayAttrs._ARRAY_DIMENSIONS as string[];\n  const shape = array.shape;\n  const chunks = array.chunks;\n\n  const loaders = Object.fromEntries(\n    await Promise.all(\n      levels.map(async (level: number) => [\n        `${level}/${variable}`,\n        await zarr.open(location.resolve(`${level}/${variable}`), {\n          kind: \"array\",\n        }),\n      ]),\n    ),\n  );\n\n  const dimArrs = Object.fromEntries(\n    await Promise.all(\n      dimensions.map(async (dim) => {\n        const dimArray = await zarr.open(location.resolve(`${levels[0]}/${dim}`), {\n          kind: \"array\",\n        });\n        const data = await zarr.get(dimArray);\n        return [dim, Array.from(data.data as Float32Array)];\n      }),\n    ),\n  );\n\n  return {\n    loaders,\n    dimensions,\n    dimArrs,\n    levels,\n    maxZoom,\n    tileSize,\n    crs,\n    shape: shape as number[],\n    chunks: chunks as number[],\n    fillValue: 0, // TODO should we get rid of fillValue since zarrita?\n  };\n};\n\nconst loadZarrV3 = async (\n  source: string,\n  variable: string,\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>,\n) => {\n  const createStore = createFetchStore(transformRequest);\n  const store = await createStore(source);\n\n  const grp = await zarr.open.v3(store, { kind: \"group\" });\n  const rootAttrs = grp.attrs as Record<string, unknown>;\n  const multiscales = rootAttrs.multiscales as Multiscale[];\n  const { levels, maxZoom, tileSize, crs } = getPyramidMetadata(multiscales);\n\n  // Use zarr.root() to create a Location, then resolve paths\n  const location = zarr.root(store);\n  const array = await zarr.open(location.resolve(`${levels[0]}/${variable}`), {\n    kind: \"array\",\n  });\n\n  const arrayAttrs = array.attrs as Record<string, unknown>;\n  const dimensions = arrayAttrs._ARRAY_DIMENSIONS as string[];\n  const shape = array.shape;\n  const chunks = array.chunks;\n\n  const loaders = Object.fromEntries(\n    await Promise.all(\n      levels.map(async (level: number) => [\n        `${level}/${variable}`,\n        await zarr.open(location.resolve(`${level}/${variable}`), {\n          kind: \"array\",\n        }),\n      ]),\n    ),\n  );\n\n  const dimArrs = Object.fromEntries(\n    await Promise.all(\n      dimensions.map(async (dim) => {\n        const dimArray = await zarr.open(location.resolve(`${levels[0]}/${dim}`), {\n          kind: \"array\",\n        });\n        const data = await zarr.get(dimArray);\n        return [dim, Array.from(data.data as Float32Array)];\n      }),\n    ),\n  );\n\n  return {\n    loaders,\n    dimensions,\n    dimArrs,\n    levels,\n    maxZoom,\n    tileSize,\n    crs,\n    shape: shape as number[],\n    chunks: chunks as number[],\n    fillValue: 0, // TODO should we get rid of fillValue since zarrita?\n  };\n};\n\nconst loadZarr = async (\n  source: string,\n  variable: string,\n  version: \"v2\" | \"v3\",\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>,\n): ReturnType<typeof loadZarrV2> => {\n  return version === \"v2\"\n    ? loadZarrV2(source, variable, transformRequest)\n    : loadZarrV3(source, variable, transformRequest);\n};\n\nexport default loadZarr;\n","import type { Map } from \"mapbox-gl\";\nimport {\n  zoomToLevel,\n  tileToScale,\n  createShader,\n  createProgram,\n  getTilesAtZoom,\n  tileToKey,\n  TileTuple,\n  lat2tile,\n  lon2tile,\n  mustGetUniformLocation,\n  mustCreateTexture,\n  mustCreateFramebuffer,\n  mustCreateBuffer,\n  ChunkTuple,\n} from \"./utils\";\nimport Tile, { Loader } from \"./tile\";\nimport zarrLoad from \"./store\";\nimport fragmentSource from \"./shaders/frag.glsl\";\nimport vertexSource from \"./shaders/vert.glsl\";\nimport renderFragmentSource from \"./shaders/renderFrag.glsl\";\nimport renderVertexSource from \"./shaders/renderVert.glsl\";\nimport type { RequestParameters } from \"./store\";\n\ntype RGB = [number, number, number];\n\nexport interface ZarrLayerProps {\n  map: Map;\n  id: string; // id for the layer, must be unique\n  source: string; // Zarr source URL\n  version: \"v2\" | \"v3\"; // Zarr version\n  variable: string; // Zarr variable to display\n  selector: Record<string, number>; // index into dimensions\n  colormap: RGB[]; // array of RGB triplets in 0-255\n  vmin: number; // lower bound for colormap\n  vmax: number; // upper bound for colormap\n  opacity?: number;\n  minRenderZoom?: number;\n  invalidate?: () => void;\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>;\n}\n\nexport class ZarrLayer {\n  type: \"custom\";\n  renderingMode: \"2d\";\n\n  map: Map;\n  id: string;\n  zarrSource: string;\n  zarrVersion: \"v2\" | \"v3\";\n  variable: string;\n  selector: Record<string, number>;\n  invalidate: () => void;\n  transformRequest?: (url: string) => RequestParameters | Promise<RequestParameters>;\n\n  cmapLength: number;\n  cmap: Float32Array;\n  vmin: number;\n  vmax: number;\n  opacity: number;\n  minRenderZoom: number;\n\n  loaders: Record<string, Loader>;\n  tiles: Record<string, Tile>;\n  maxZoom: number;\n  fillValue: number;\n\n  private gl: WebGL2RenderingContext | undefined;\n  private program: WebGLProgram;\n\n  private scaleLoc: WebGLUniformLocation;\n  private shiftXLoc: WebGLUniformLocation;\n  private shiftYLoc: WebGLUniformLocation;\n  private matrixLoc: WebGLUniformLocation;\n\n  private vminLoc: WebGLUniformLocation;\n  private vmaxLoc: WebGLUniformLocation;\n  private opacityLoc: WebGLUniformLocation;\n  private noDataLoc: WebGLUniformLocation;\n\n  private vertexLoc: number;\n  private cmapTex: WebGLTexture;\n  private cmapLoc: WebGLUniformLocation;\n\n  private vertexArr: Float32Array;\n  private pixCoordArr: Float32Array;\n\n  private texLoc: WebGLUniformLocation;\n  private pixCoordLoc: GLint;\n\n  private frameBuffers: {\n    current: {\n      framebuffer: WebGLFramebuffer;\n      texture: WebGLTexture;\n    } | null;\n    next: {\n      framebuffer: WebGLFramebuffer;\n      texture: WebGLTexture;\n    } | null;\n  };\n  private isUpdating: boolean;\n  private canvasWidth: number;\n  private canvasHeight: number;\n\n  private renderProgram: WebGLProgram;\n  private renderVertexLoc: number;\n  private renderTexLoc: WebGLUniformLocation;\n  private vertexBuffer: WebGLBuffer;\n\n  constructor({\n    id,\n    source,\n    version,\n    variable,\n    selector,\n    map,\n    colormap,\n    vmin,\n    vmax,\n    opacity = 1,\n    minRenderZoom = 3,\n    invalidate = () => {},\n    transformRequest,\n  }: ZarrLayerProps) {\n    this.type = \"custom\";\n    this.renderingMode = \"2d\";\n\n    this.id = id;\n    this.zarrSource = source;\n    this.zarrVersion = version;\n    this.variable = variable;\n    this.selector = selector ?? {};\n\n    this.invalidate = invalidate;\n    this.transformRequest = transformRequest;\n\n    this.cmap = new Float32Array(colormap.flat().map((v) => v / 255.0));\n    this.cmapLength = colormap.length;\n    this.vmin = vmin;\n    this.vmax = vmax;\n    this.opacity = opacity;\n    this.minRenderZoom = minRenderZoom;\n\n    this.map = map;\n\n    this.loaders = {};\n    this.tiles = {};\n    this.maxZoom = 4; // Default value, will be updated from Zarr metadata\n    this.fillValue = 0; // Default value, will be updated from Zarr metadata\n\n    this.frameBuffers = { current: null, next: null };\n    this.isUpdating = false;\n    this.canvasWidth = 512; // Default size, will be updated\n    this.canvasHeight = 512;\n  }\n\n  setOpacity(opacity: number) {\n    this.opacity = opacity;\n    this.invalidate();\n  }\n\n  setVminVmax(vmin: number, vmax: number) {\n    this.vmin = vmin;\n    this.vmax = vmax;\n    this.invalidate();\n  }\n\n  async setVariable(variable: string) {\n    this.variable = variable;\n    this.tiles = {};\n    await this.prepareTiles();\n    this.getVisibleTiles();\n    await this.prefetchTileData();\n    this.invalidate();\n  }\n\n  async setSelector(selector: Record<string, number>) {\n    this.selector = selector;\n    await this.prefetchTileData();\n    this.invalidate();\n  }\n\n  async prefetchTileData() {\n    const tiles = this.getVisibleTiles();\n    const fetchPromises = tiles\n      .map((tiletuple) => {\n        const tilekey = tileToKey(tiletuple);\n        const tile = this.tiles[tilekey];\n        if (tile && !tile.data) {\n          return tile.fetchData(this.selector);\n        }\n        return null;\n      })\n      .filter((p) => p !== null);\n\n    if (fetchPromises.length > 0) {\n      await Promise.all(fetchPromises);\n      this.invalidate();\n    }\n  }\n\n  getVisibleTiles(): TileTuple[] {\n    const zoom = zoomToLevel(this.map.getZoom(), this.maxZoom);\n\n    // If we don't have a loader for this zoom level just give up...\n    if (!this.loaders[zoom]) return [];\n\n    const bounds = this.map.getBounds()?.toArray();\n    if (!bounds) {\n      throw new Error(\"Couldn't get map bounds\");\n    }\n    return getTilesAtZoom(zoom, bounds);\n  }\n\n  async prepareTiles() {\n    if (typeof this.gl === \"undefined\") {\n      throw new Error(\"Cant prepareTiles with no GL context set\");\n    }\n    const gl = this.gl;\n    const { loaders, dimensions, dimArrs, levels, maxZoom, shape, chunks, fillValue } =\n      await zarrLoad(this.zarrSource, this.variable, this.zarrVersion, this.transformRequest);\n\n    // TODO check if selector references non-existent dimensions\n\n    this.maxZoom = maxZoom;\n    this.fillValue = fillValue;\n    levels.forEach((z: number) => {\n      const loaderKey = z + \"/\" + this.variable;\n      const loader = loaders[loaderKey];\n      if (!loader) {\n        throw new Error(`Failed to get loader for ${loaderKey}`);\n      }\n      this.loaders[z] = loader;\n      Array.from({ length: Math.pow(2, z) }, (_, x) => {\n        Array.from({ length: Math.pow(2, z) }, (_, y) => {\n          const key = [z, x, y].join(\",\");\n          const chunk: ChunkTuple = [y, x]; // NOTE: chunks go [Y, X]\n          // TODO most of these probably dont need to go into Tile\n          this.tiles[key] = new Tile({\n            chunk,\n            chunks,\n            loader,\n            gl,\n            dimensions,\n            dimArrs,\n            shape,\n            z,\n            x,\n            y,\n          });\n        });\n      });\n    });\n  }\n\n  async getTileValue(lng: number, lat: number, x: number, y: number): Promise<number> {\n    const zoom = this.maxZoom;\n    const tileTuple: TileTuple = [zoom, lon2tile(lng, zoom), lat2tile(lat, zoom)];\n    const tileKey = tileToKey(tileTuple);\n    const tile = this.tiles[tileKey];\n    if (tile) {\n      const [_, shiftX, shiftY] = tileToScale(tileTuple);\n      const [xLocal, yLocal] = [x - shiftX, y - shiftY];\n      const data = await tile.fetchData(this.selector);\n      // assume x and y are always present in tile dimensions\n      const tileWidth = tile.getDimension(\"x\")!;\n      const tileHeight = tile.getDimension(\"y\")!;\n      const [xIndex, yIndex] = [\n        Math.round(xLocal * tileWidth * 2 ** zoom),\n        Math.round(yLocal * tileHeight * 2 ** zoom),\n      ];\n      const index = yIndex * tileWidth + xIndex;\n      const val = data[index];\n      if (val) {\n        return val;\n      }\n    }\n    return -1;\n  }\n\n  async onAdd(_map: Map, gl: WebGL2RenderingContext) {\n    this.gl = gl;\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n    this.program = createProgram(gl, vertexShader, fragmentShader);\n\n    this.scaleLoc = mustGetUniformLocation(gl, this.program, \"scale\");\n    this.shiftXLoc = mustGetUniformLocation(gl, this.program, \"shift_x\");\n    this.shiftYLoc = mustGetUniformLocation(gl, this.program, \"shift_y\");\n    this.matrixLoc = mustGetUniformLocation(gl, this.program, \"matrix\");\n\n    this.vminLoc = mustGetUniformLocation(gl, this.program, \"vmin\");\n    this.vmaxLoc = mustGetUniformLocation(gl, this.program, \"vmax\");\n    this.opacityLoc = mustGetUniformLocation(gl, this.program, \"opacity\");\n    this.noDataLoc = mustGetUniformLocation(gl, this.program, \"nodata\");\n\n    // There is a single global texture for the colormap\n    this.cmapTex = mustCreateTexture(gl);\n    this.cmapLoc = mustGetUniformLocation(gl, this.program, \"cmap\");\n\n    // The texture for each tile is created in the Tile constructor\n    this.texLoc = mustGetUniformLocation(gl, this.program, \"tex\");\n\n    // The `vertex` controls the location for the vertex shader\n    this.vertexLoc = gl.getAttribLocation(this.program, \"vertex\");\n    // prettier-ignore\n    this.vertexArr = new Float32Array([\n      -1.0,  1.0, // left top\n      -1.0, -1.0, // left bottom\n       1.0,  1.0, // right top\n       1.0, -1.0, // right bottom\n    ]);\n\n    // While this texCoord controls the fragment shader pixel \"lookup\"\n    this.pixCoordLoc = gl.getAttribLocation(this.program, \"pix_coord_in\");\n    // prettier-ignore\n    this.pixCoordArr = new Float32Array([\n      0.0, 0.0, // left side\n      0.0, 1.0,\n      1.0, 0.0, // right side\n      1.0, 1.0,\n    ]);\n\n    this.canvasWidth = gl.canvas.width;\n    this.canvasHeight = gl.canvas.height;\n    this.frameBuffers.current = mustCreateFramebuffer(gl, this.canvasWidth, this.canvasHeight);\n    this.frameBuffers.next = mustCreateFramebuffer(gl, this.canvasWidth, this.canvasHeight);\n\n    await this.prepareTiles();\n\n    this.vertexBuffer = mustCreateBuffer(gl);\n\n    const renderVertShader = createShader(gl, gl.VERTEX_SHADER, renderVertexSource);\n\n    const renderFragShader = createShader(gl, gl.FRAGMENT_SHADER, renderFragmentSource);\n\n    this.renderProgram = createProgram(gl, renderVertShader, renderFragShader);\n    this.renderVertexLoc = gl.getAttribLocation(this.renderProgram, \"vertex\");\n    this.renderTexLoc = mustGetUniformLocation(gl, this.renderProgram, \"tex\");\n\n    // Clean up shaders\n    gl.deleteShader(renderVertShader);\n    gl.deleteShader(renderFragShader);\n\n    // Trigger initial data load\n    await this.prefetchTileData();\n  }\n\n  prerender(gl: WebGL2RenderingContext, matrix: number[]) {\n    if (this.isUpdating) return;\n\n    // Check if canvas size has changed\n    gl.useProgram(this.program);\n    if (gl.canvas.width !== this.canvasWidth || gl.canvas.height !== this.canvasHeight) {\n      this.canvasWidth = gl.canvas.width;\n      this.canvasHeight = gl.canvas.height;\n      this.frameBuffers.current = mustCreateFramebuffer(gl, this.canvasWidth, this.canvasHeight);\n      this.frameBuffers.next = mustCreateFramebuffer(gl, this.canvasWidth, this.canvasHeight);\n    }\n\n    // First copy the current framebuffer to the next one\n    // prettier-ignore\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffers.next!.framebuffer);\n    // prettier-ignore\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffers.current!.framebuffer);\n    // prettier-ignore\n    gl.blitFramebuffer(0, 0, this.canvasWidth, this.canvasHeight, 0, 0, this.canvasWidth, this.canvasHeight, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n\n    // Render to the next buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffers.next!.framebuffer);\n    gl.viewport(0, 0, this.canvasWidth, this.canvasHeight);\n\n    // Call useProgram once right at the start\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    // This is the colormap\n    // First activate TEXTURE1, bind the unofirm, set the parameters\n    // and then upload the texture\n    // Important that these happen in roughly this order!\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, this.cmapTex);\n    gl.uniform1i(this.cmapLoc, 1);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // iOS Safari only supports RGB16F\n    // prettier-ignore\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB16F, this.cmapLength, 1, 0, gl.RGB, gl.FLOAT, this.cmap);\n\n    // Set the basic uniforms for color handling\n    gl.uniform1f(this.vminLoc, this.vmin);\n    gl.uniform1f(this.vmaxLoc, this.vmax);\n    gl.uniform1f(this.opacityLoc, this.opacity);\n    gl.uniform1f(this.noDataLoc, this.fillValue);\n\n    // The Mapbox matrix maps map-space coordinates to GLSL-space\n    gl.uniformMatrix4fv(this.matrixLoc, false, matrix);\n\n    const tiles = this.getVisibleTiles();\n    // We don't await this, and just hope it finishes loading\n    // by the next time we come around??\n    // This is because Mapbox/WebGL doesn't like it if we await here\n    // and all sorts of weird stuff happens\n    this.prefetchTileData();\n\n    for (const tileTuple of tiles) {\n      const tileKey = tileToKey(tileTuple);\n      const tile = this.tiles[tileKey];\n      if (!tile) continue;\n\n      // We don't await this, and just hope it finishes loading\n      // by the next time we come around??\n      // This is because Mapbox/WebGL doesn't like it if we await here\n      // and all sorts of weird stuff happens\n      if (!tile.data) continue;\n\n      // These are used to scale and shift the this.bufferData\n      // coordinates from covering the whole canvas to just the part\n      // that the tile covers\n      const [scale, shiftX, shiftY] = tileToScale(tileTuple);\n      gl.uniform1f(this.scaleLoc, scale);\n      gl.uniform1f(this.shiftXLoc, shiftX);\n      gl.uniform1f(this.shiftYLoc, shiftY);\n\n      // For some reason it is quite important for these two bind+buffer\n      // to happen before the texture stuff\n      gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, this.vertexArr, gl.STATIC_DRAW);\n      gl.bindBuffer(gl.ARRAY_BUFFER, tile.pixCoordBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, this.pixCoordArr, gl.STATIC_DRAW);\n\n      // Bind and set texture for the tile\n      // As with cmap, the order here is important\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, tile.tileTexture);\n      gl.uniform1i(this.texLoc, 0);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      // assume x and y are always present in tile dimensions\n      const tileWidth = tile.getDimension(\"x\")!;\n      const tileHeight = tile.getDimension(\"y\")!;\n      // iOS Safari only supports RGB16F\n      // prettier-ignore\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.R16F, tileWidth, tileHeight, 0, gl.RED, gl.FLOAT, tile.data);\n\n      // These are the vertex and pixCoord that were buffered+bound\n      // further up. For some reason this has to happen _after_ the\n      // texture stuff??\n      gl.enableVertexAttribArray(this.vertexLoc);\n      gl.vertexAttribPointer(this.vertexLoc, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(this.pixCoordLoc);\n      gl.vertexAttribPointer(this.pixCoordLoc, 2, gl.FLOAT, false, 0, 0);\n\n      // Enable blending and draw the tile\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n\n    // Swap buffers\n    const temp = this.frameBuffers.current;\n    this.frameBuffers.current = this.frameBuffers.next;\n    this.frameBuffers.next = temp;\n\n    this.isUpdating = false;\n  }\n\n  render(gl: WebGL2RenderingContext, _matrix: number[]) {\n    if (!this.frameBuffers.current) return;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvasWidth, this.canvasHeight);\n\n    gl.useProgram(this.renderProgram);\n\n    // Bind the framebuffer texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.frameBuffers.current.texture);\n    gl.uniform1i(this.renderTexLoc, 0);\n\n    // Set up vertices for a full-screen quad\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(this.renderVertexLoc);\n    gl.vertexAttribPointer(this.renderVertexLoc, 2, gl.FLOAT, false, 0, 0);\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n}\n"],"names":["installedChunks","installChunk","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","d","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","data","ids","modules","runtime","i","length","j","installedChunkData","push","promise","import","then","race","resolve","lon2tile","lon","zoom","Math","floor","pow","lat2tile","lat","log","tan","PI","cos","tileToKey","tile","join","tileToScale","z","x","y","scale","createShader","gl","type","source","shader","Error","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","msg","getShaderInfoLog","deleteShader","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","mustGetUniformLocation","name","loc","getUniformLocation","mustCreateTexture","tex","createTexture","mustCreateBuffer","buf","createBuffer","mustCreateFramebuffer","width","height","framebuffer","createFramebuffer","texture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","BoolArray","constructor","byteOffset","this","Uint8Array","ArrayBuffer","Array","from","v","BYTES_PER_ELEMENT","byteLength","buffer","idx","set","fill","iterator","ByteStringArray","_data","chars","TextEncoder","values","view","TextDecoder","decode","replace","encode","encoded","UnicodeStringArray","Int32Array","str","offset","result","String","fromCodePoint","subarray","codePointAt","json_decode_object","bytes","JSON","parse","byteswap_inplace","bytes_per_element","numFlips","endByteIndex","t","get_ctr","data_type","globalThis","match","kind","bind","Number","ctr","int8","Int8Array","int16","Int16Array","int32","int64","BigInt64Array","uint8","uint16","Uint16Array","uint32","Uint32Array","uint64","BigUint64Array","float16","Float16Array","float32","Float32Array","float64","Float64Array","bool","assert","get_strides","shape","order","rank","_","step","stride","create_chunk_key_encoder","configuration","separator","chunk_coords","is_sharding_codec","codec","ensure_correct_scalar","metadata","fill_value","BigInt","rethrow_unless","error","errors","some","ErrorClass","expression","async","decompress","format","signal","response","Response","body","decompressedResponse","pipeThrough","DecompressionStream","arrayBuffer","throwIfAborted","BitroundCodec","_meta","keepbits","fromConfig","meta","_arr","arr","LITTLE_ENDIAN_OS","a","system_is_little_endian","TypedArray","BytesCodec","endian","sample","Crc32cCodec","GzipCodec","_bytes","throw_on_nan_replacer","_key","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","sort_keys_replacer","isArray","sort","sorted","JsonCodec","encoding","skipkeys","ensure_ascii","check_circular","allow_nan","sort_keys","indent","strict","separators","replacer_functions","items","replacer","new_value","sub_replacer","json_str","stringify","chr","full_str","charCodeAt","toString","substring","pop","proxy","Proxy","target","TransposeCodec","inverseOrder","forEach","chunk","map","s","index","b","entry","get_order","every","dim","matches_order","src","out","empty_like","n_dims","size","src_data","out_data","src_idx","out_idx","convert_array_order","VLenUTF8","_chunk","decoder","DataView","getUint32","pos","item_length","slice","ZlibCodec","registry","Map","default","create_codec_pipeline","chunk_metadata","codecs","load_codecs","array_to_array","array_to_bytes","bytes_to_bytes","chunk_meta","Codec","MAX_BIG_UINT","create_sharded_chunk_getter","location","shard_shape","encode_shard_key","sharding_config","store","getRange","get_range","index_shape","chunk_shape","index_codec","index_codecs","cache","chunk_coord","shard_coord","shard_path","path","checksum_size","index_size","suffixLength","linear_offset","acc","sel","Location","root","URL","endsWith","decodeURIComponent","pathname","Group","super","attrs","attributes","get_array_order","maybe_transpose_codec","find","c","CONTEXT_MARKER","shared_context","encode_chunk_key","chunk_key_encoding","native_order","get_chunk_bytes","chunk_grid","options","chunk_key","chunk_path","create_context","chunks","dtype","getChunk","context","maybe_bytes","is","query","is_boolean","is_string","startsWith","is_bigint","is_object","is_dtype","start","stop","IndexError","IntDimIndexer","dim_sel","dim_len","dim_chunk_len","nitems","trunc","err_boundscheck","normalize_integer_selection","dim_chunk_ix","dim_offset","dim_chunk_sel","SliceDimIndexer","nchunks","step_is_negative","lower","upper","slice_indices","err_negative_step","max","ceil","dim_chunk_ix_from","dim_chunk_ix_to","range","dim_limit","min","dim_out_offset","dim_chunk_sel_start","remainder","dim_chunk_sel_stop","dim_out_sel","BasicIndexer","dim_indexers","selection","normalized","err_too_many_indices","check_selection_length","normalize_selection","filter","ixr","sixr","dim_projections","iterables","iterators","it","results","next","done","product","p","mapping","to","object_array_view","compat_chunk","setter","prepare","set_scalar","dest","set_scalar_binary","get_typed_array_constructor","compat_scalar","set_from_chunk","projections","set_from_chunk_binary","opts","indexer","queue","create_queue","add","fn","onIdle","unwrap","indices_len","out_selection","slices","curr_stride","len","proj","projs","dstride","dstrides","sstride","sstrides","sfrom","sstep","loader","dimensions","dimArrs","dataCache","loading","loadingPromise","tileTexture","vertexBuffer","pixCoordBuffer","fetchData","selector","neededChunks","includes","flatMap","tuple","chunkSize","coords","selectorValue","indices","indexOf","uniqueChunkIndices","Set","chunkIndex","getChunks","chunkKey","indexIntoChunk","findIndex","coordinate","pick","getDimension","dimension","fetch_range","url","headers","Range","fetch","base","resolved","search","handle_response","status","statusText","overrides","useSuffixRequest","storeOverrides","requestOverrides","href","init","suffix_length","use_suffix_request","method","ok","content_length","fetch_suffix","NodeNotFoundError","KeyError","VERSION_COUNTER","version_counts","WeakMap","get_counts","counts","v2","v3","increment","version","version_max","create_version_counter","open_array_v2","cause","rest","b1","i1","u1","i2","u2","i4","u4","i8","u8","f2","f4","f8","coerce_dtype","id","filters","compressor","zarr_format","node_type","dimension_separator","v2_to_v3_array_metadata","open_group_v2","v2_to_v3_group_metadata","open_primary","open_secondary","catch","err","meta_bytes","load_attrs","node","meta_doc","_open_v3","createFetchStore","transformRequest","requestParams","credentials","getPyramidMetadata","multiscales","datasets","levels","dataset","maxZoom","tileSize","pixels_per_tile","crs","ZarrLayer","renderingMode","zarrSource","zarrVersion","variable","invalidate","cmapLength","cmap","vmin","vmax","opacity","minRenderZoom","loaders","tiles","fillValue","scaleLoc","shiftXLoc","shiftYLoc","matrixLoc","vminLoc","vmaxLoc","opacityLoc","noDataLoc","vertexLoc","cmapTex","cmapLoc","vertexArr","pixCoordArr","texLoc","pixCoordLoc","frameBuffers","isUpdating","canvasWidth","canvasHeight","renderProgram","renderVertexLoc","renderTexLoc","colormap","flat","current","setOpacity","setVminVmax","setVariable","prepareTiles","getVisibleTiles","prefetchTileData","setSelector","fetchPromises","tiletuple","tilekey","zoomToLevel","getZoom","bounds","getBounds","toArray","west","south","east","north","nwX","seX","nwY","seY","getTilesAtZoom","createStore","array","_ARRAY_DIMENSIONS","fromEntries","level","dimArray","loadZarrV2","loadZarrV3","loaderKey","getTileValue","lng","tileTuple","tileKey","shiftX","shiftY","xLocal","yLocal","tileWidth","tileHeight","xIndex","yIndex","round","val","onAdd","_map","VERTEX_SHADER","FRAGMENT_SHADER","getAttribLocation","canvas","renderVertShader","renderFragShader","prerender","matrix","useProgram","DRAW_FRAMEBUFFER","READ_FRAMEBUFFER","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","viewport","clearColor","clear","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","activeTexture","TEXTURE1","uniform1i","RGB16F","RGB","FLOAT","uniform1f","uniformMatrix4fv","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","TEXTURE0","R16F","RED","enableVertexAttribArray","vertexAttribPointer","drawArrays","TRIANGLE_STRIP","temp","render","_matrix"],"sourceRoot":""}